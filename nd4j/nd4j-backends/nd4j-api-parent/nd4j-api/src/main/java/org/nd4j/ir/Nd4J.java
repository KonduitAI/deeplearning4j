// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nd4j.proto

package org.nd4j.ir;

public final class Nd4J {
  private Nd4J() {}
  public static void registerAllExtensions(
      org.nd4j.shade.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      org.nd4j.shade.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (org.nd4j.shade.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * Protobuf enum {@code org.nd4j.ir.DataType}
   */
  public enum DataType
      implements org.nd4j.shade.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNDEFINED = 0;</code>
     */
    UNDEFINED(0),
    /**
     * <pre>
     * Basic types.
     * </pre>
     *
     * <code>FLOAT = 1;</code>
     */
    FLOAT(1),
    /**
     * <pre>
     * uint8_t
     * </pre>
     *
     * <code>UINT8 = 2;</code>
     */
    UINT8(2),
    /**
     * <pre>
     * int8_t
     * </pre>
     *
     * <code>INT8 = 3;</code>
     */
    INT8(3),
    /**
     * <pre>
     * uint16_t
     * </pre>
     *
     * <code>UINT16 = 4;</code>
     */
    UINT16(4),
    /**
     * <pre>
     * int16_t
     * </pre>
     *
     * <code>INT16 = 5;</code>
     */
    INT16(5),
    /**
     * <pre>
     * int32_t
     * </pre>
     *
     * <code>INT32 = 6;</code>
     */
    INT32(6),
    /**
     * <pre>
     * int64_t
     * </pre>
     *
     * <code>INT64 = 7;</code>
     */
    INT64(7),
    /**
     * <pre>
     * string
     * </pre>
     *
     * <code>STRING = 8;</code>
     */
    STRING(8),
    /**
     * <pre>
     * bool
     * </pre>
     *
     * <code>BOOL = 9;</code>
     */
    BOOL(9),
    /**
     * <pre>
     * IEEE754 half-precision floating-point format (16 bits wide).
     * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
     * </pre>
     *
     * <code>FLOAT16 = 10;</code>
     */
    FLOAT16(10),
    /**
     * <code>DOUBLE = 11;</code>
     */
    DOUBLE(11),
    /**
     * <code>UINT32 = 12;</code>
     */
    UINT32(12),
    /**
     * <code>UINT64 = 13;</code>
     */
    UINT64(13),
    /**
     * <pre>
     * complex with float32 real and imaginary components
     * </pre>
     *
     * <code>COMPLEX64 = 14;</code>
     */
    COMPLEX64(14),
    /**
     * <pre>
     * complex with float64 real and imaginary components
     * </pre>
     *
     * <code>COMPLEX128 = 15;</code>
     */
    COMPLEX128(15),
    /**
     * <pre>
     * Non-IEEE floating-point format based on IEEE754 single-precision
     * floating-point number truncated to 16 bits.
     * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
     * </pre>
     *
     * <code>BFLOAT16 = 16;</code>
     */
    BFLOAT16(16),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNDEFINED = 0;</code>
     */
    public static final int UNDEFINED_VALUE = 0;
    /**
     * <pre>
     * Basic types.
     * </pre>
     *
     * <code>FLOAT = 1;</code>
     */
    public static final int FLOAT_VALUE = 1;
    /**
     * <pre>
     * uint8_t
     * </pre>
     *
     * <code>UINT8 = 2;</code>
     */
    public static final int UINT8_VALUE = 2;
    /**
     * <pre>
     * int8_t
     * </pre>
     *
     * <code>INT8 = 3;</code>
     */
    public static final int INT8_VALUE = 3;
    /**
     * <pre>
     * uint16_t
     * </pre>
     *
     * <code>UINT16 = 4;</code>
     */
    public static final int UINT16_VALUE = 4;
    /**
     * <pre>
     * int16_t
     * </pre>
     *
     * <code>INT16 = 5;</code>
     */
    public static final int INT16_VALUE = 5;
    /**
     * <pre>
     * int32_t
     * </pre>
     *
     * <code>INT32 = 6;</code>
     */
    public static final int INT32_VALUE = 6;
    /**
     * <pre>
     * int64_t
     * </pre>
     *
     * <code>INT64 = 7;</code>
     */
    public static final int INT64_VALUE = 7;
    /**
     * <pre>
     * string
     * </pre>
     *
     * <code>STRING = 8;</code>
     */
    public static final int STRING_VALUE = 8;
    /**
     * <pre>
     * bool
     * </pre>
     *
     * <code>BOOL = 9;</code>
     */
    public static final int BOOL_VALUE = 9;
    /**
     * <pre>
     * IEEE754 half-precision floating-point format (16 bits wide).
     * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
     * </pre>
     *
     * <code>FLOAT16 = 10;</code>
     */
    public static final int FLOAT16_VALUE = 10;
    /**
     * <code>DOUBLE = 11;</code>
     */
    public static final int DOUBLE_VALUE = 11;
    /**
     * <code>UINT32 = 12;</code>
     */
    public static final int UINT32_VALUE = 12;
    /**
     * <code>UINT64 = 13;</code>
     */
    public static final int UINT64_VALUE = 13;
    /**
     * <pre>
     * complex with float32 real and imaginary components
     * </pre>
     *
     * <code>COMPLEX64 = 14;</code>
     */
    public static final int COMPLEX64_VALUE = 14;
    /**
     * <pre>
     * complex with float64 real and imaginary components
     * </pre>
     *
     * <code>COMPLEX128 = 15;</code>
     */
    public static final int COMPLEX128_VALUE = 15;
    /**
     * <pre>
     * Non-IEEE floating-point format based on IEEE754 single-precision
     * floating-point number truncated to 16 bits.
     * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
     * </pre>
     *
     * <code>BFLOAT16 = 16;</code>
     */
    public static final int BFLOAT16_VALUE = 16;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DataType valueOf(int value) {
      return forNumber(value);
    }

    public static DataType forNumber(int value) {
      switch (value) {
        case 0: return UNDEFINED;
        case 1: return FLOAT;
        case 2: return UINT8;
        case 3: return INT8;
        case 4: return UINT16;
        case 5: return INT16;
        case 6: return INT32;
        case 7: return INT64;
        case 8: return STRING;
        case 9: return BOOL;
        case 10: return FLOAT16;
        case 11: return DOUBLE;
        case 12: return UINT32;
        case 13: return UINT64;
        case 14: return COMPLEX64;
        case 15: return COMPLEX128;
        case 16: return BFLOAT16;
        default: return null;
      }
    }

    public static org.nd4j.shade.protobuf.Internal.EnumLiteMap<DataType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final org.nd4j.shade.protobuf.Internal.EnumLiteMap<
        DataType> internalValueMap =
          new org.nd4j.shade.protobuf.Internal.EnumLiteMap<DataType>() {
            public DataType findValueByNumber(int number) {
              return DataType.forNumber(number);
            }
          };

    public final org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.getDescriptor().getEnumTypes().get(0);
    }

    private static final DataType[] VALUES = values();

    public static DataType valueOf(
        org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DataType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:org.nd4j.ir.DataType)
  }

  /**
   * Protobuf enum {@code org.nd4j.ir.OpListType}
   */
  public enum OpListType
      implements org.nd4j.shade.protobuf.ProtocolMessageEnum {
    /**
     * <code>TARG = 0;</code>
     */
    TARG(0),
    /**
     * <code>IARG = 1;</code>
     */
    IARG(1),
    /**
     * <code>BARG = 2;</code>
     */
    BARG(2),
    /**
     * <code>DTYPEARG = 3;</code>
     */
    DTYPEARG(3),
    /**
     * <code>INPUTARG = 4;</code>
     */
    INPUTARG(4),
    /**
     * <code>OUTPUTARG = 5;</code>
     */
    OUTPUTARG(5),
    /**
     * <code>AXISARG = 6;</code>
     */
    AXISARG(6),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>TARG = 0;</code>
     */
    public static final int TARG_VALUE = 0;
    /**
     * <code>IARG = 1;</code>
     */
    public static final int IARG_VALUE = 1;
    /**
     * <code>BARG = 2;</code>
     */
    public static final int BARG_VALUE = 2;
    /**
     * <code>DTYPEARG = 3;</code>
     */
    public static final int DTYPEARG_VALUE = 3;
    /**
     * <code>INPUTARG = 4;</code>
     */
    public static final int INPUTARG_VALUE = 4;
    /**
     * <code>OUTPUTARG = 5;</code>
     */
    public static final int OUTPUTARG_VALUE = 5;
    /**
     * <code>AXISARG = 6;</code>
     */
    public static final int AXISARG_VALUE = 6;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static OpListType valueOf(int value) {
      return forNumber(value);
    }

    public static OpListType forNumber(int value) {
      switch (value) {
        case 0: return TARG;
        case 1: return IARG;
        case 2: return BARG;
        case 3: return DTYPEARG;
        case 4: return INPUTARG;
        case 5: return OUTPUTARG;
        case 6: return AXISARG;
        default: return null;
      }
    }

    public static org.nd4j.shade.protobuf.Internal.EnumLiteMap<OpListType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final org.nd4j.shade.protobuf.Internal.EnumLiteMap<
        OpListType> internalValueMap =
          new org.nd4j.shade.protobuf.Internal.EnumLiteMap<OpListType>() {
            public OpListType findValueByNumber(int number) {
              return OpListType.forNumber(number);
            }
          };

    public final org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.getDescriptor().getEnumTypes().get(1);
    }

    private static final OpListType[] VALUES = values();

    public static OpListType valueOf(
        org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private OpListType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:org.nd4j.ir.OpListType)
  }

  public interface StringStringEntryProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.StringStringEntryProto)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <code>string key = 1;</code>
     */
    java.lang.String getKey();
    /**
     * <code>string key = 1;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>string value = 2;</code>
     */
    java.lang.String getValue();
    /**
     * <code>string value = 2;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getValueBytes();
  }
  /**
   * <pre>
   * StringStringEntryProto follows the pattern for cross-proto-version maps.
   * See https://developers.google.com/protocol-buffers/docs/proto3#maps
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.StringStringEntryProto}
   */
  public  static final class StringStringEntryProto extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.StringStringEntryProto)
      StringStringEntryProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use StringStringEntryProto.newBuilder() to construct.
    private StringStringEntryProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private StringStringEntryProto() {
      key_ = "";
      value_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new StringStringEntryProto();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private StringStringEntryProto(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              key_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              value_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.StringStringEntryProto.class, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;
    private volatile java.lang.Object key_;
    /**
     * <code>string key = 1;</code>
     */
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        key_ = s;
        return s;
      }
    }
    /**
     * <code>string key = 1;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private volatile java.lang.Object value_;
    /**
     * <code>string value = 2;</code>
     */
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        value_ = s;
        return s;
      }
    }
    /**
     * <code>string value = 2;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getKeyBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      if (!getValueBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getKeyBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      if (!getValueBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.StringStringEntryProto)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.StringStringEntryProto other = (org.nd4j.ir.Nd4J.StringStringEntryProto) obj;

      if (!getKey()
          .equals(other.getKey())) return false;
      if (!getValue()
          .equals(other.getValue())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_FIELD_NUMBER;
      hash = (53 * hash) + getKey().hashCode();
      hash = (37 * hash) + VALUE_FIELD_NUMBER;
      hash = (53 * hash) + getValue().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.StringStringEntryProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.StringStringEntryProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StringStringEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.StringStringEntryProto}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.StringStringEntryProto)
        org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.StringStringEntryProto.class, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.StringStringEntryProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        key_ = "";

        value_ = "";

        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.StringStringEntryProto getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.StringStringEntryProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.StringStringEntryProto build() {
        org.nd4j.ir.Nd4J.StringStringEntryProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.StringStringEntryProto buildPartial() {
        org.nd4j.ir.Nd4J.StringStringEntryProto result = new org.nd4j.ir.Nd4J.StringStringEntryProto(this);
        result.key_ = key_;
        result.value_ = value_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.StringStringEntryProto) {
          return mergeFrom((org.nd4j.ir.Nd4J.StringStringEntryProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.StringStringEntryProto other) {
        if (other == org.nd4j.ir.Nd4J.StringStringEntryProto.getDefaultInstance()) return this;
        if (!other.getKey().isEmpty()) {
          key_ = other.key_;
          onChanged();
        }
        if (!other.getValue().isEmpty()) {
          value_ = other.value_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.StringStringEntryProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.StringStringEntryProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object key_ = "";
      /**
       * <code>string key = 1;</code>
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          key_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string key = 1;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string key = 1;</code>
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string key = 1;</code>
       */
      public Builder clearKey() {
        
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <code>string key = 1;</code>
       */
      public Builder setKeyBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        key_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object value_ = "";
      /**
       * <code>string value = 2;</code>
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          value_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string value = 2;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string value = 2;</code>
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string value = 2;</code>
       */
      public Builder clearValue() {
        
        value_ = getDefaultInstance().getValue();
        onChanged();
        return this;
      }
      /**
       * <code>string value = 2;</code>
       */
      public Builder setValueBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        value_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.StringStringEntryProto)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.StringStringEntryProto)
    private static final org.nd4j.ir.Nd4J.StringStringEntryProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.StringStringEntryProto();
    }

    public static org.nd4j.ir.Nd4J.StringStringEntryProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<StringStringEntryProto>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<StringStringEntryProto>() {
      @java.lang.Override
      public StringStringEntryProto parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new StringStringEntryProto(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<StringStringEntryProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<StringStringEntryProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.StringStringEntryProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TypeProto)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    boolean hasTensorType();
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    org.nd4j.ir.Nd4J.TypeProto.Tensor getTensorType();
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder getTensorTypeOrBuilder();

    public org.nd4j.ir.Nd4J.TypeProto.ValueCase getValueCase();
  }
  /**
   * <pre>
   * Define the types.
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.TypeProto}
   */
  public  static final class TypeProto extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.TypeProto)
      TypeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TypeProto.newBuilder() to construct.
    private TypeProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TypeProto() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TypeProto();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TypeProto(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder subBuilder = null;
              if (valueCase_ == 1) {
                subBuilder = ((org.nd4j.ir.Nd4J.TypeProto.Tensor) value_).toBuilder();
              }
              value_ =
                  input.readMessage(org.nd4j.ir.Nd4J.TypeProto.Tensor.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((org.nd4j.ir.Nd4J.TypeProto.Tensor) value_);
                value_ = subBuilder.buildPartial();
              }
              valueCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.TypeProto.class, org.nd4j.ir.Nd4J.TypeProto.Builder.class);
    }

    public interface TensorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TypeProto.Tensor)
        org.nd4j.shade.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
       */
      int getElemTypeValue();
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
       */
      org.nd4j.ir.Nd4J.DataType getElemType();

      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      boolean hasShape();
      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      org.nd4j.ir.Nd4J.TensorShapeProto getShape();
      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder getShapeOrBuilder();
    }
    /**
     * Protobuf type {@code org.nd4j.ir.TypeProto.Tensor}
     */
    public  static final class Tensor extends
        org.nd4j.shade.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:org.nd4j.ir.TypeProto.Tensor)
        TensorOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Tensor.newBuilder() to construct.
      private Tensor(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Tensor() {
        elemType_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Tensor();
      }

      @java.lang.Override
      public final org.nd4j.shade.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Tensor(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
            org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int rawValue = input.readEnum();

                elemType_ = rawValue;
                break;
              }
              case 18: {
                org.nd4j.ir.Nd4J.TensorShapeProto.Builder subBuilder = null;
                if (shape_ != null) {
                  subBuilder = shape_.toBuilder();
                }
                shape_ = input.readMessage(org.nd4j.ir.Nd4J.TensorShapeProto.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(shape_);
                  shape_ = subBuilder.buildPartial();
                }

                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_Tensor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TypeProto.Tensor.class, org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder.class);
      }

      public static final int ELEM_TYPE_FIELD_NUMBER = 1;
      private int elemType_;
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
       */
      public int getElemTypeValue() {
        return elemType_;
      }
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
       */
      public org.nd4j.ir.Nd4J.DataType getElemType() {
        @SuppressWarnings("deprecation")
        org.nd4j.ir.Nd4J.DataType result = org.nd4j.ir.Nd4J.DataType.valueOf(elemType_);
        return result == null ? org.nd4j.ir.Nd4J.DataType.UNRECOGNIZED : result;
      }

      public static final int SHAPE_FIELD_NUMBER = 2;
      private org.nd4j.ir.Nd4J.TensorShapeProto shape_;
      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      public boolean hasShape() {
        return shape_ != null;
      }
      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto getShape() {
        return shape_ == null ? org.nd4j.ir.Nd4J.TensorShapeProto.getDefaultInstance() : shape_;
      }
      /**
       * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder getShapeOrBuilder() {
        return getShape();
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (elemType_ != org.nd4j.ir.Nd4J.DataType.UNDEFINED.getNumber()) {
          output.writeEnum(1, elemType_);
        }
        if (shape_ != null) {
          output.writeMessage(2, getShape());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (elemType_ != org.nd4j.ir.Nd4J.DataType.UNDEFINED.getNumber()) {
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeEnumSize(1, elemType_);
        }
        if (shape_ != null) {
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeMessageSize(2, getShape());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.nd4j.ir.Nd4J.TypeProto.Tensor)) {
          return super.equals(obj);
        }
        org.nd4j.ir.Nd4J.TypeProto.Tensor other = (org.nd4j.ir.Nd4J.TypeProto.Tensor) obj;

        if (elemType_ != other.elemType_) return false;
        if (hasShape() != other.hasShape()) return false;
        if (hasShape()) {
          if (!getShape()
              .equals(other.getShape())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + elemType_;
        if (hasShape()) {
          hash = (37 * hash) + SHAPE_FIELD_NUMBER;
          hash = (53 * hash) + getShape().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          java.nio.ByteBuffer data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          java.nio.ByteBuffer data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          org.nd4j.shade.protobuf.ByteString data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          org.nd4j.shade.protobuf.ByteString data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(byte[] data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          byte[] data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseDelimitedFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TypeProto.Tensor parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.nd4j.ir.Nd4J.TypeProto.Tensor prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code org.nd4j.ir.TypeProto.Tensor}
       */
      public static final class Builder extends
          org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TypeProto.Tensor)
          org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder {
        public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor;
        }

        @java.lang.Override
        protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_Tensor_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.nd4j.ir.Nd4J.TypeProto.Tensor.class, org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder.class);
        }

        // Construct using org.nd4j.ir.Nd4J.TypeProto.Tensor.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (org.nd4j.shade.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          elemType_ = 0;

          if (shapeBuilder_ == null) {
            shape_ = null;
          } else {
            shape_ = null;
            shapeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TypeProto.Tensor getDefaultInstanceForType() {
          return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TypeProto.Tensor build() {
          org.nd4j.ir.Nd4J.TypeProto.Tensor result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TypeProto.Tensor buildPartial() {
          org.nd4j.ir.Nd4J.TypeProto.Tensor result = new org.nd4j.ir.Nd4J.TypeProto.Tensor(this);
          result.elemType_ = elemType_;
          if (shapeBuilder_ == null) {
            result.shape_ = shape_;
          } else {
            result.shape_ = shapeBuilder_.build();
          }
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
          if (other instanceof org.nd4j.ir.Nd4J.TypeProto.Tensor) {
            return mergeFrom((org.nd4j.ir.Nd4J.TypeProto.Tensor)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.nd4j.ir.Nd4J.TypeProto.Tensor other) {
          if (other == org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance()) return this;
          if (other.elemType_ != 0) {
            setElemTypeValue(other.getElemTypeValue());
          }
          if (other.hasShape()) {
            mergeShape(other.getShape());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.nd4j.ir.Nd4J.TypeProto.Tensor parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.nd4j.ir.Nd4J.TypeProto.Tensor) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int elemType_ = 0;
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
         */
        public int getElemTypeValue() {
          return elemType_;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
         */
        public Builder setElemTypeValue(int value) {
          elemType_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
         */
        public org.nd4j.ir.Nd4J.DataType getElemType() {
          @SuppressWarnings("deprecation")
          org.nd4j.ir.Nd4J.DataType result = org.nd4j.ir.Nd4J.DataType.valueOf(elemType_);
          return result == null ? org.nd4j.ir.Nd4J.DataType.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
         */
        public Builder setElemType(org.nd4j.ir.Nd4J.DataType value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          elemType_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>.org.nd4j.ir.DataType elem_type = 1;</code>
         */
        public Builder clearElemType() {
          
          elemType_ = 0;
          onChanged();
          return this;
        }

        private org.nd4j.ir.Nd4J.TensorShapeProto shape_;
        private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
            org.nd4j.ir.Nd4J.TensorShapeProto, org.nd4j.ir.Nd4J.TensorShapeProto.Builder, org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder> shapeBuilder_;
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public boolean hasShape() {
          return shapeBuilder_ != null || shape_ != null;
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public org.nd4j.ir.Nd4J.TensorShapeProto getShape() {
          if (shapeBuilder_ == null) {
            return shape_ == null ? org.nd4j.ir.Nd4J.TensorShapeProto.getDefaultInstance() : shape_;
          } else {
            return shapeBuilder_.getMessage();
          }
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(org.nd4j.ir.Nd4J.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            shape_ = value;
            onChanged();
          } else {
            shapeBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(
            org.nd4j.ir.Nd4J.TensorShapeProto.Builder builderForValue) {
          if (shapeBuilder_ == null) {
            shape_ = builderForValue.build();
            onChanged();
          } else {
            shapeBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public Builder mergeShape(org.nd4j.ir.Nd4J.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (shape_ != null) {
              shape_ =
                org.nd4j.ir.Nd4J.TensorShapeProto.newBuilder(shape_).mergeFrom(value).buildPartial();
            } else {
              shape_ = value;
            }
            onChanged();
          } else {
            shapeBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public Builder clearShape() {
          if (shapeBuilder_ == null) {
            shape_ = null;
            onChanged();
          } else {
            shape_ = null;
            shapeBuilder_ = null;
          }

          return this;
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public org.nd4j.ir.Nd4J.TensorShapeProto.Builder getShapeBuilder() {
          
          onChanged();
          return getShapeFieldBuilder().getBuilder();
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        public org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder getShapeOrBuilder() {
          if (shapeBuilder_ != null) {
            return shapeBuilder_.getMessageOrBuilder();
          } else {
            return shape_ == null ?
                org.nd4j.ir.Nd4J.TensorShapeProto.getDefaultInstance() : shape_;
          }
        }
        /**
         * <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
         */
        private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
            org.nd4j.ir.Nd4J.TensorShapeProto, org.nd4j.ir.Nd4J.TensorShapeProto.Builder, org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder> 
            getShapeFieldBuilder() {
          if (shapeBuilder_ == null) {
            shapeBuilder_ = new org.nd4j.shade.protobuf.SingleFieldBuilderV3<
                org.nd4j.ir.Nd4J.TensorShapeProto, org.nd4j.ir.Nd4J.TensorShapeProto.Builder, org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder>(
                    getShape(),
                    getParentForChildren(),
                    isClean());
            shape_ = null;
          }
          return shapeBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TypeProto.Tensor)
      }

      // @@protoc_insertion_point(class_scope:org.nd4j.ir.TypeProto.Tensor)
      private static final org.nd4j.ir.Nd4J.TypeProto.Tensor DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TypeProto.Tensor();
      }

      public static org.nd4j.ir.Nd4J.TypeProto.Tensor getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final org.nd4j.shade.protobuf.Parser<Tensor>
          PARSER = new org.nd4j.shade.protobuf.AbstractParser<Tensor>() {
        @java.lang.Override
        public Tensor parsePartialFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
          return new Tensor(input, extensionRegistry);
        }
      };

      public static org.nd4j.shade.protobuf.Parser<Tensor> parser() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Parser<Tensor> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TypeProto.Tensor getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int valueCase_ = 0;
    private java.lang.Object value_;
    public enum ValueCase
        implements org.nd4j.shade.protobuf.Internal.EnumLite {
      TENSOR_TYPE(1),
      VALUE_NOT_SET(0);
      private final int value;
      private ValueCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValueCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValueCase forNumber(int value) {
        switch (value) {
          case 1: return TENSOR_TYPE;
          case 0: return VALUE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ValueCase
    getValueCase() {
      return ValueCase.forNumber(
          valueCase_);
    }

    public static final int TENSOR_TYPE_FIELD_NUMBER = 1;
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    public boolean hasTensorType() {
      return valueCase_ == 1;
    }
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    public org.nd4j.ir.Nd4J.TypeProto.Tensor getTensorType() {
      if (valueCase_ == 1) {
         return (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_;
      }
      return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
    }
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
     */
    public org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
      if (valueCase_ == 1) {
         return (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_;
      }
      return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (valueCase_ == 1) {
        output.writeMessage(1, (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (valueCase_ == 1) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(1, (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.TypeProto)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.TypeProto other = (org.nd4j.ir.Nd4J.TypeProto) obj;

      if (!getValueCase().equals(other.getValueCase())) return false;
      switch (valueCase_) {
        case 1:
          if (!getTensorType()
              .equals(other.getTensorType())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (valueCase_) {
        case 1:
          hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getTensorType().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TypeProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.TypeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Define the types.
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.TypeProto}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TypeProto)
        org.nd4j.ir.Nd4J.TypeProtoOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TypeProto.class, org.nd4j.ir.Nd4J.TypeProto.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.TypeProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        valueCase_ = 0;
        value_ = null;
        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TypeProto_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TypeProto getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.TypeProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TypeProto build() {
        org.nd4j.ir.Nd4J.TypeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TypeProto buildPartial() {
        org.nd4j.ir.Nd4J.TypeProto result = new org.nd4j.ir.Nd4J.TypeProto(this);
        if (valueCase_ == 1) {
          if (tensorTypeBuilder_ == null) {
            result.value_ = value_;
          } else {
            result.value_ = tensorTypeBuilder_.build();
          }
        }
        result.valueCase_ = valueCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.TypeProto) {
          return mergeFrom((org.nd4j.ir.Nd4J.TypeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.TypeProto other) {
        if (other == org.nd4j.ir.Nd4J.TypeProto.getDefaultInstance()) return this;
        switch (other.getValueCase()) {
          case TENSOR_TYPE: {
            mergeTensorType(other.getTensorType());
            break;
          }
          case VALUE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.TypeProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.TypeProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int valueCase_ = 0;
      private java.lang.Object value_;
      public ValueCase
          getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public Builder clearValue() {
        valueCase_ = 0;
        value_ = null;
        onChanged();
        return this;
      }


      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TypeProto.Tensor, org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder, org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder> tensorTypeBuilder_;
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public boolean hasTensorType() {
        return valueCase_ == 1;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProto.Tensor getTensorType() {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1) {
            return (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_;
          }
          return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
        } else {
          if (valueCase_ == 1) {
            return tensorTypeBuilder_.getMessage();
          }
          return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder setTensorType(org.nd4j.ir.Nd4J.TypeProto.Tensor value) {
        if (tensorTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          tensorTypeBuilder_.setMessage(value);
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder setTensorType(
          org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder builderForValue) {
        if (tensorTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          tensorTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder mergeTensorType(org.nd4j.ir.Nd4J.TypeProto.Tensor value) {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1 &&
              value_ != org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance()) {
            value_ = org.nd4j.ir.Nd4J.TypeProto.Tensor.newBuilder((org.nd4j.ir.Nd4J.TypeProto.Tensor) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 1) {
            tensorTypeBuilder_.mergeFrom(value);
          }
          tensorTypeBuilder_.setMessage(value);
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder clearTensorType() {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
          }
          tensorTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder getTensorTypeBuilder() {
        return getTensorTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
        if ((valueCase_ == 1) && (tensorTypeBuilder_ != null)) {
          return tensorTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 1) {
            return (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_;
          }
          return org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto.Tensor tensor_type = 1;</code>
       */
      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TypeProto.Tensor, org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder, org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder> 
          getTensorTypeFieldBuilder() {
        if (tensorTypeBuilder_ == null) {
          if (!(valueCase_ == 1)) {
            value_ = org.nd4j.ir.Nd4J.TypeProto.Tensor.getDefaultInstance();
          }
          tensorTypeBuilder_ = new org.nd4j.shade.protobuf.SingleFieldBuilderV3<
              org.nd4j.ir.Nd4J.TypeProto.Tensor, org.nd4j.ir.Nd4J.TypeProto.Tensor.Builder, org.nd4j.ir.Nd4J.TypeProto.TensorOrBuilder>(
                  (org.nd4j.ir.Nd4J.TypeProto.Tensor) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 1;
        onChanged();;
        return tensorTypeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TypeProto)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.TypeProto)
    private static final org.nd4j.ir.Nd4J.TypeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TypeProto();
    }

    public static org.nd4j.ir.Nd4J.TypeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<TypeProto>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<TypeProto>() {
      @java.lang.Override
      public TypeProto parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new TypeProto(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<TypeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<TypeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.TypeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TensorShapeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TensorShapeProto)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> 
        getDimList();
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDim(int index);
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    int getDimCount();
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    java.util.List<? extends org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder> 
        getDimOrBuilderList();
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Defines a tensor shape. A dimension can be either an integer value
   * or a symbolic variable. A symbolic variable represents an unknown
   * dimension.
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.TensorShapeProto}
   */
  public  static final class TensorShapeProto extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.TensorShapeProto)
      TensorShapeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TensorShapeProto.newBuilder() to construct.
    private TensorShapeProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TensorShapeProto() {
      dim_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TensorShapeProto();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TensorShapeProto(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                dim_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension>();
                mutable_bitField0_ |= 0x00000001;
              }
              dim_.add(
                  input.readMessage(org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          dim_ = java.util.Collections.unmodifiableList(dim_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.TensorShapeProto.class, org.nd4j.ir.Nd4J.TensorShapeProto.Builder.class);
    }

    public interface DimensionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TensorShapeProto.Dimension)
        org.nd4j.shade.protobuf.MessageOrBuilder {

      /**
       * <code>int64 dim_value = 1;</code>
       */
      long getDimValue();

      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       */
      java.lang.String getDimParam();
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       */
      org.nd4j.shade.protobuf.ByteString
          getDimParamBytes();

      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.ValueCase getValueCase();
    }
    /**
     * Protobuf type {@code org.nd4j.ir.TensorShapeProto.Dimension}
     */
    public  static final class Dimension extends
        org.nd4j.shade.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:org.nd4j.ir.TensorShapeProto.Dimension)
        DimensionOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Dimension.newBuilder() to construct.
      private Dimension(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Dimension() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Dimension();
      }

      @java.lang.Override
      public final org.nd4j.shade.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Dimension(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
            org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                valueCase_ = 1;
                value_ = input.readInt64();
                break;
              }
              case 18: {
                java.lang.String s = input.readStringRequireUtf8();
                valueCase_ = 2;
                value_ = s;
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.class, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder.class);
      }

      private int valueCase_ = 0;
      private java.lang.Object value_;
      public enum ValueCase
          implements org.nd4j.shade.protobuf.Internal.EnumLite {
        DIM_VALUE(1),
        DIM_PARAM(2),
        VALUE_NOT_SET(0);
        private final int value;
        private ValueCase(int value) {
          this.value = value;
        }
        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ValueCase valueOf(int value) {
          return forNumber(value);
        }

        public static ValueCase forNumber(int value) {
          switch (value) {
            case 1: return DIM_VALUE;
            case 2: return DIM_PARAM;
            case 0: return VALUE_NOT_SET;
            default: return null;
          }
        }
        public int getNumber() {
          return this.value;
        }
      };

      public ValueCase
      getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public static final int DIM_VALUE_FIELD_NUMBER = 1;
      /**
       * <code>int64 dim_value = 1;</code>
       */
      public long getDimValue() {
        if (valueCase_ == 1) {
          return (java.lang.Long) value_;
        }
        return 0L;
      }

      public static final int DIM_PARAM_FIELD_NUMBER = 2;
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       */
      public java.lang.String getDimParam() {
        java.lang.Object ref = "";
        if (valueCase_ == 2) {
          ref = value_;
        }
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          org.nd4j.shade.protobuf.ByteString bs = 
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (valueCase_ == 2) {
            value_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getDimParamBytes() {
        java.lang.Object ref = "";
        if (valueCase_ == 2) {
          ref = value_;
        }
        if (ref instanceof java.lang.String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (valueCase_ == 2) {
            value_ = b;
          }
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (valueCase_ == 1) {
          output.writeInt64(
              1, (long)((java.lang.Long) value_));
        }
        if (valueCase_ == 2) {
          org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (valueCase_ == 1) {
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt64Size(
                1, (long)((java.lang.Long) value_));
        }
        if (valueCase_ == 2) {
          size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.nd4j.ir.Nd4J.TensorShapeProto.Dimension)) {
          return super.equals(obj);
        }
        org.nd4j.ir.Nd4J.TensorShapeProto.Dimension other = (org.nd4j.ir.Nd4J.TensorShapeProto.Dimension) obj;

        if (!getValueCase().equals(other.getValueCase())) return false;
        switch (valueCase_) {
          case 1:
            if (getDimValue()
                != other.getDimValue()) return false;
            break;
          case 2:
            if (!getDimParam()
                .equals(other.getDimParam())) return false;
            break;
          case 0:
          default:
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        switch (valueCase_) {
          case 1:
            hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
            hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong(
                getDimValue());
            break;
          case 2:
            hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
            hash = (53 * hash) + getDimParam().hashCode();
            break;
          case 0:
          default:
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          java.nio.ByteBuffer data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          java.nio.ByteBuffer data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          org.nd4j.shade.protobuf.ByteString data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          org.nd4j.shade.protobuf.ByteString data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(byte[] data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          byte[] data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseDelimitedFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.nd4j.ir.Nd4J.TensorShapeProto.Dimension prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code org.nd4j.ir.TensorShapeProto.Dimension}
       */
      public static final class Builder extends
          org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TensorShapeProto.Dimension)
          org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder {
        public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor;
        }

        @java.lang.Override
        protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.class, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder.class);
        }

        // Construct using org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (org.nd4j.shade.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          valueCase_ = 0;
          value_ = null;
          return this;
        }

        @java.lang.Override
        public org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDefaultInstanceForType() {
          return org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.getDefaultInstance();
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension build() {
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension buildPartial() {
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension result = new org.nd4j.ir.Nd4J.TensorShapeProto.Dimension(this);
          if (valueCase_ == 1) {
            result.value_ = value_;
          }
          if (valueCase_ == 2) {
            result.value_ = value_;
          }
          result.valueCase_ = valueCase_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
          if (other instanceof org.nd4j.ir.Nd4J.TensorShapeProto.Dimension) {
            return mergeFrom((org.nd4j.ir.Nd4J.TensorShapeProto.Dimension)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.nd4j.ir.Nd4J.TensorShapeProto.Dimension other) {
          if (other == org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.getDefaultInstance()) return this;
          switch (other.getValueCase()) {
            case DIM_VALUE: {
              setDimValue(other.getDimValue());
              break;
            }
            case DIM_PARAM: {
              valueCase_ = 2;
              value_ = other.value_;
              onChanged();
              break;
            }
            case VALUE_NOT_SET: {
              break;
            }
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.nd4j.ir.Nd4J.TensorShapeProto.Dimension) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int valueCase_ = 0;
        private java.lang.Object value_;
        public ValueCase
            getValueCase() {
          return ValueCase.forNumber(
              valueCase_);
        }

        public Builder clearValue() {
          valueCase_ = 0;
          value_ = null;
          onChanged();
          return this;
        }


        /**
         * <code>int64 dim_value = 1;</code>
         */
        public long getDimValue() {
          if (valueCase_ == 1) {
            return (java.lang.Long) value_;
          }
          return 0L;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         */
        public Builder setDimValue(long value) {
          valueCase_ = 1;
          value_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         */
        public Builder clearDimValue() {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
          return this;
        }

        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         */
        public java.lang.String getDimParam() {
          java.lang.Object ref = "";
          if (valueCase_ == 2) {
            ref = value_;
          }
          if (!(ref instanceof java.lang.String)) {
            org.nd4j.shade.protobuf.ByteString bs =
                (org.nd4j.shade.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (valueCase_ == 2) {
              value_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         */
        public org.nd4j.shade.protobuf.ByteString
            getDimParamBytes() {
          java.lang.Object ref = "";
          if (valueCase_ == 2) {
            ref = value_;
          }
          if (ref instanceof String) {
            org.nd4j.shade.protobuf.ByteString b = 
                org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            if (valueCase_ == 2) {
              value_ = b;
            }
            return b;
          } else {
            return (org.nd4j.shade.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         */
        public Builder setDimParam(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  valueCase_ = 2;
          value_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         */
        public Builder clearDimParam() {
          if (valueCase_ == 2) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         */
        public Builder setDimParamBytes(
            org.nd4j.shade.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          valueCase_ = 2;
          value_ = value;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorShapeProto.Dimension)
      }

      // @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorShapeProto.Dimension)
      private static final org.nd4j.ir.Nd4J.TensorShapeProto.Dimension DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TensorShapeProto.Dimension();
      }

      public static org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final org.nd4j.shade.protobuf.Parser<Dimension>
          PARSER = new org.nd4j.shade.protobuf.AbstractParser<Dimension>() {
        @java.lang.Override
        public Dimension parsePartialFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
          return new Dimension(input, extensionRegistry);
        }
      };

      public static org.nd4j.shade.protobuf.Parser<Dimension> parser() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Parser<Dimension> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int DIM_FIELD_NUMBER = 1;
    private java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> dim_;
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    public java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> getDimList() {
      return dim_;
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    public java.util.List<? extends org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder> 
        getDimOrBuilderList() {
      return dim_;
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    public int getDimCount() {
      return dim_.size();
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDim(int index) {
      return dim_.get(index);
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
     */
    public org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
        int index) {
      return dim_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dim_.size(); i++) {
        output.writeMessage(1, dim_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < dim_.size(); i++) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(1, dim_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.TensorShapeProto)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.TensorShapeProto other = (org.nd4j.ir.Nd4J.TensorShapeProto) obj;

      if (!getDimList()
          .equals(other.getDimList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDimCount() > 0) {
        hash = (37 * hash) + DIM_FIELD_NUMBER;
        hash = (53 * hash) + getDimList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorShapeProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.TensorShapeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Defines a tensor shape. A dimension can be either an integer value
     * or a symbolic variable. A symbolic variable represents an unknown
     * dimension.
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.TensorShapeProto}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TensorShapeProto)
        org.nd4j.ir.Nd4J.TensorShapeProtoOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TensorShapeProto.class, org.nd4j.ir.Nd4J.TensorShapeProto.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.TensorShapeProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getDimFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (dimBuilder_ == null) {
          dim_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          dimBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorShapeProto_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorShapeProto getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.TensorShapeProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorShapeProto build() {
        org.nd4j.ir.Nd4J.TensorShapeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorShapeProto buildPartial() {
        org.nd4j.ir.Nd4J.TensorShapeProto result = new org.nd4j.ir.Nd4J.TensorShapeProto(this);
        int from_bitField0_ = bitField0_;
        if (dimBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            dim_ = java.util.Collections.unmodifiableList(dim_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.dim_ = dim_;
        } else {
          result.dim_ = dimBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.TensorShapeProto) {
          return mergeFrom((org.nd4j.ir.Nd4J.TensorShapeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.TensorShapeProto other) {
        if (other == org.nd4j.ir.Nd4J.TensorShapeProto.getDefaultInstance()) return this;
        if (dimBuilder_ == null) {
          if (!other.dim_.isEmpty()) {
            if (dim_.isEmpty()) {
              dim_ = other.dim_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureDimIsMutable();
              dim_.addAll(other.dim_);
            }
            onChanged();
          }
        } else {
          if (!other.dim_.isEmpty()) {
            if (dimBuilder_.isEmpty()) {
              dimBuilder_.dispose();
              dimBuilder_ = null;
              dim_ = other.dim_;
              bitField0_ = (bitField0_ & ~0x00000001);
              dimBuilder_ = 
                org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getDimFieldBuilder() : null;
            } else {
              dimBuilder_.addAllMessages(other.dim_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.TensorShapeProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.TensorShapeProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> dim_ =
        java.util.Collections.emptyList();
      private void ensureDimIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          dim_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension>(dim_);
          bitField0_ |= 0x00000001;
         }
      }

      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder, org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder> dimBuilder_;

      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> getDimList() {
        if (dimBuilder_ == null) {
          return java.util.Collections.unmodifiableList(dim_);
        } else {
          return dimBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public int getDimCount() {
        if (dimBuilder_ == null) {
          return dim_.size();
        } else {
          return dimBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension getDim(int index) {
        if (dimBuilder_ == null) {
          return dim_.get(index);
        } else {
          return dimBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder setDim(
          int index, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.set(index, value);
          onChanged();
        } else {
          dimBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder setDim(
          int index, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.set(index, builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(org.nd4j.ir.Nd4J.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.add(value);
          onChanged();
        } else {
          dimBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          int index, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.add(index, value);
          onChanged();
        } else {
          dimBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.add(builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          int index, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.add(index, builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addAllDim(
          java.lang.Iterable<? extends org.nd4j.ir.Nd4J.TensorShapeProto.Dimension> values) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
              values, dim_);
          onChanged();
        } else {
          dimBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder clearDim() {
        if (dimBuilder_ == null) {
          dim_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          dimBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder removeDim(int index) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.remove(index);
          onChanged();
        } else {
          dimBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder getDimBuilder(
          int index) {
        return getDimFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
          int index) {
        if (dimBuilder_ == null) {
          return dim_.get(index);  } else {
          return dimBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<? extends org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder> 
           getDimOrBuilderList() {
        if (dimBuilder_ != null) {
          return dimBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(dim_);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder addDimBuilder() {
        return getDimFieldBuilder().addBuilder(
            org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.getDefaultInstance());
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder addDimBuilder(
          int index) {
        return getDimFieldBuilder().addBuilder(
            index, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.getDefaultInstance());
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder> 
           getDimBuilderList() {
        return getDimFieldBuilder().getBuilderList();
      }
      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorShapeProto.Dimension, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder, org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder> 
          getDimFieldBuilder() {
        if (dimBuilder_ == null) {
          dimBuilder_ = new org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
              org.nd4j.ir.Nd4J.TensorShapeProto.Dimension, org.nd4j.ir.Nd4J.TensorShapeProto.Dimension.Builder, org.nd4j.ir.Nd4J.TensorShapeProto.DimensionOrBuilder>(
                  dim_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          dim_ = null;
        }
        return dimBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorShapeProto)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorShapeProto)
    private static final org.nd4j.ir.Nd4J.TensorShapeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TensorShapeProto();
    }

    public static org.nd4j.ir.Nd4J.TensorShapeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<TensorShapeProto>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<TensorShapeProto>() {
      @java.lang.Override
      public TensorShapeProto parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new TensorShapeProto(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<TensorShapeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<TensorShapeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.TensorShapeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValueInfoProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.ValueInfoProto)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    org.nd4j.ir.Nd4J.TypeProto getType();
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    org.nd4j.ir.Nd4J.TypeProtoOrBuilder getTypeOrBuilder();

    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 3;</code>
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 3;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getDocStringBytes();
  }
  /**
   * <pre>
   * Defines information on value, including the name, the type, and
   * the shape of the value.
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.ValueInfoProto}
   */
  public  static final class ValueInfoProto extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.ValueInfoProto)
      ValueInfoProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValueInfoProto.newBuilder() to construct.
    private ValueInfoProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValueInfoProto() {
      name_ = "";
      docString_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ValueInfoProto();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValueInfoProto(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              org.nd4j.ir.Nd4J.TypeProto.Builder subBuilder = null;
              if (type_ != null) {
                subBuilder = type_.toBuilder();
              }
              type_ = input.readMessage(org.nd4j.ir.Nd4J.TypeProto.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(type_);
                type_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              docString_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_ValueInfoProto_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.ValueInfoProto.class, org.nd4j.ir.Nd4J.ValueInfoProto.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private org.nd4j.ir.Nd4J.TypeProto type_;
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    public boolean hasType() {
      return type_ != null;
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    public org.nd4j.ir.Nd4J.TypeProto getType() {
      return type_ == null ? org.nd4j.ir.Nd4J.TypeProto.getDefaultInstance() : type_;
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>.org.nd4j.ir.TypeProto type = 2;</code>
     */
    public org.nd4j.ir.Nd4J.TypeProtoOrBuilder getTypeOrBuilder() {
      return getType();
    }

    public static final int DOC_STRING_FIELD_NUMBER = 3;
    private volatile java.lang.Object docString_;
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 3;</code>
     */
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        docString_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 3;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (type_ != null) {
        output.writeMessage(2, getType());
      }
      if (!getDocStringBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 3, docString_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (type_ != null) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(2, getType());
      }
      if (!getDocStringBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(3, docString_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.ValueInfoProto)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.ValueInfoProto other = (org.nd4j.ir.Nd4J.ValueInfoProto) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (!getDocString()
          .equals(other.getDocString())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
      hash = (53 * hash) + getDocString().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.ValueInfoProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.ValueInfoProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Defines information on value, including the name, the type, and
     * the shape of the value.
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.ValueInfoProto}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.ValueInfoProto)
        org.nd4j.ir.Nd4J.ValueInfoProtoOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_ValueInfoProto_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.ValueInfoProto.class, org.nd4j.ir.Nd4J.ValueInfoProto.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.ValueInfoProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        if (typeBuilder_ == null) {
          type_ = null;
        } else {
          type_ = null;
          typeBuilder_ = null;
        }
        docString_ = "";

        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_ValueInfoProto_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.ValueInfoProto getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.ValueInfoProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.ValueInfoProto build() {
        org.nd4j.ir.Nd4J.ValueInfoProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.ValueInfoProto buildPartial() {
        org.nd4j.ir.Nd4J.ValueInfoProto result = new org.nd4j.ir.Nd4J.ValueInfoProto(this);
        result.name_ = name_;
        if (typeBuilder_ == null) {
          result.type_ = type_;
        } else {
          result.type_ = typeBuilder_.build();
        }
        result.docString_ = docString_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.ValueInfoProto) {
          return mergeFrom((org.nd4j.ir.Nd4J.ValueInfoProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.ValueInfoProto other) {
        if (other == org.nd4j.ir.Nd4J.ValueInfoProto.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasType()) {
          mergeType(other.getType());
        }
        if (!other.getDocString().isEmpty()) {
          docString_ = other.docString_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.ValueInfoProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.ValueInfoProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private org.nd4j.ir.Nd4J.TypeProto type_;
      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TypeProto, org.nd4j.ir.Nd4J.TypeProto.Builder, org.nd4j.ir.Nd4J.TypeProtoOrBuilder> typeBuilder_;
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public boolean hasType() {
        return typeBuilder_ != null || type_ != null;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProto getType() {
        if (typeBuilder_ == null) {
          return type_ == null ? org.nd4j.ir.Nd4J.TypeProto.getDefaultInstance() : type_;
        } else {
          return typeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public Builder setType(org.nd4j.ir.Nd4J.TypeProto value) {
        if (typeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          typeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public Builder setType(
          org.nd4j.ir.Nd4J.TypeProto.Builder builderForValue) {
        if (typeBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          typeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public Builder mergeType(org.nd4j.ir.Nd4J.TypeProto value) {
        if (typeBuilder_ == null) {
          if (type_ != null) {
            type_ =
              org.nd4j.ir.Nd4J.TypeProto.newBuilder(type_).mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          typeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public Builder clearType() {
        if (typeBuilder_ == null) {
          type_ = null;
          onChanged();
        } else {
          type_ = null;
          typeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProto.Builder getTypeBuilder() {
        
        onChanged();
        return getTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      public org.nd4j.ir.Nd4J.TypeProtoOrBuilder getTypeOrBuilder() {
        if (typeBuilder_ != null) {
          return typeBuilder_.getMessageOrBuilder();
        } else {
          return type_ == null ?
              org.nd4j.ir.Nd4J.TypeProto.getDefaultInstance() : type_;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>.org.nd4j.ir.TypeProto type = 2;</code>
       */
      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TypeProto, org.nd4j.ir.Nd4J.TypeProto.Builder, org.nd4j.ir.Nd4J.TypeProtoOrBuilder> 
          getTypeFieldBuilder() {
        if (typeBuilder_ == null) {
          typeBuilder_ = new org.nd4j.shade.protobuf.SingleFieldBuilderV3<
              org.nd4j.ir.Nd4J.TypeProto, org.nd4j.ir.Nd4J.TypeProto.Builder, org.nd4j.ir.Nd4J.TypeProtoOrBuilder>(
                  getType(),
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        return typeBuilder_;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 3;</code>
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          docString_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 3;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 3;</code>
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        docString_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 3;</code>
       */
      public Builder clearDocString() {
        
        docString_ = getDefaultInstance().getDocString();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 3;</code>
       */
      public Builder setDocStringBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        docString_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.ValueInfoProto)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.ValueInfoProto)
    private static final org.nd4j.ir.Nd4J.ValueInfoProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.ValueInfoProto();
    }

    public static org.nd4j.ir.Nd4J.ValueInfoProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<ValueInfoProto>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<ValueInfoProto>() {
      @java.lang.Override
      public ValueInfoProto parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new ValueInfoProto(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<ValueInfoProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<ValueInfoProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.ValueInfoProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TensorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TensorProto)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    java.util.List<java.lang.Long> getDimsList();
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    int getDimsCount();
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    long getDims(int index);

    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>int32 data_type = 2;</code>
     */
    int getDataType();

    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    boolean hasSegment();
    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    org.nd4j.ir.Nd4J.TensorProto.Segment getSegment();
    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder getSegmentOrBuilder();

    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    java.util.List<java.lang.Float> getFloatDataList();
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    int getFloatDataCount();
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    float getFloatData(int index);

    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    java.util.List<java.lang.Integer> getInt32DataList();
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    int getInt32DataCount();
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    int getInt32Data(int index);

    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    java.util.List<org.nd4j.shade.protobuf.ByteString> getStringDataList();
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    int getStringDataCount();
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    org.nd4j.shade.protobuf.ByteString getStringData(int index);

    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    java.util.List<java.lang.Long> getInt64DataList();
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    int getInt64DataCount();
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    long getInt64Data(int index);

    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>string name = 8;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>string name = 8;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 12;</code>
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 12;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>bytes raw_data = 9;</code>
     */
    org.nd4j.shade.protobuf.ByteString getRawData();

    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto> 
        getExternalDataList();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    org.nd4j.ir.Nd4J.StringStringEntryProto getExternalData(int index);
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    int getExternalDataCount();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    java.util.List<? extends org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder> 
        getExternalDataOrBuilderList();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
        int index);

    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
     */
    int getDataLocationValue();
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
     */
    org.nd4j.ir.Nd4J.TensorProto.DataLocation getDataLocation();

    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    java.util.List<java.lang.Double> getDoubleDataList();
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    int getDoubleDataCount();
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    double getDoubleData(int index);

    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    java.util.List<java.lang.Long> getUint64DataList();
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    int getUint64DataCount();
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    long getUint64Data(int index);
  }
  /**
   * <pre>
   * Tensors
   * A serialized tensor value.
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.TensorProto}
   */
  public  static final class TensorProto extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.TensorProto)
      TensorProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TensorProto.newBuilder() to construct.
    private TensorProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TensorProto() {
      dims_ = emptyLongList();
      floatData_ = emptyFloatList();
      int32Data_ = emptyIntList();
      stringData_ = java.util.Collections.emptyList();
      int64Data_ = emptyLongList();
      name_ = "";
      docString_ = "";
      rawData_ = org.nd4j.shade.protobuf.ByteString.EMPTY;
      externalData_ = java.util.Collections.emptyList();
      dataLocation_ = 0;
      doubleData_ = emptyDoubleList();
      uint64Data_ = emptyLongList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TensorProto();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TensorProto(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                dims_ = newLongList();
                mutable_bitField0_ |= 0x00000001;
              }
              dims_.addLong(input.readInt64());
              break;
            }
            case 10: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
                dims_ = newLongList();
                mutable_bitField0_ |= 0x00000001;
              }
              while (input.getBytesUntilLimit() > 0) {
                dims_.addLong(input.readInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 16: {

              dataType_ = input.readInt32();
              break;
            }
            case 26: {
              org.nd4j.ir.Nd4J.TensorProto.Segment.Builder subBuilder = null;
              if (segment_ != null) {
                subBuilder = segment_.toBuilder();
              }
              segment_ = input.readMessage(org.nd4j.ir.Nd4J.TensorProto.Segment.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(segment_);
                segment_ = subBuilder.buildPartial();
              }

              break;
            }
            case 37: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                floatData_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              floatData_.addFloat(input.readFloat());
              break;
            }
            case 34: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000002) != 0) && input.getBytesUntilLimit() > 0) {
                floatData_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              while (input.getBytesUntilLimit() > 0) {
                floatData_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 40: {
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                int32Data_ = newIntList();
                mutable_bitField0_ |= 0x00000004;
              }
              int32Data_.addInt(input.readInt32());
              break;
            }
            case 42: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
                int32Data_ = newIntList();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                int32Data_.addInt(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                stringData_ = new java.util.ArrayList<org.nd4j.shade.protobuf.ByteString>();
                mutable_bitField0_ |= 0x00000008;
              }
              stringData_.add(input.readBytes());
              break;
            }
            case 56: {
              if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                int64Data_ = newLongList();
                mutable_bitField0_ |= 0x00000010;
              }
              int64Data_.addLong(input.readInt64());
              break;
            }
            case 58: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000010) != 0) && input.getBytesUntilLimit() > 0) {
                int64Data_ = newLongList();
                mutable_bitField0_ |= 0x00000010;
              }
              while (input.getBytesUntilLimit() > 0) {
                int64Data_.addLong(input.readInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 66: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 74: {

              rawData_ = input.readBytes();
              break;
            }
            case 81: {
              if (!((mutable_bitField0_ & 0x00000040) != 0)) {
                doubleData_ = newDoubleList();
                mutable_bitField0_ |= 0x00000040;
              }
              doubleData_.addDouble(input.readDouble());
              break;
            }
            case 82: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000040) != 0) && input.getBytesUntilLimit() > 0) {
                doubleData_ = newDoubleList();
                mutable_bitField0_ |= 0x00000040;
              }
              while (input.getBytesUntilLimit() > 0) {
                doubleData_.addDouble(input.readDouble());
              }
              input.popLimit(limit);
              break;
            }
            case 88: {
              if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                uint64Data_ = newLongList();
                mutable_bitField0_ |= 0x00000080;
              }
              uint64Data_.addLong(input.readUInt64());
              break;
            }
            case 90: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000080) != 0) && input.getBytesUntilLimit() > 0) {
                uint64Data_ = newLongList();
                mutable_bitField0_ |= 0x00000080;
              }
              while (input.getBytesUntilLimit() > 0) {
                uint64Data_.addLong(input.readUInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 98: {
              java.lang.String s = input.readStringRequireUtf8();

              docString_ = s;
              break;
            }
            case 106: {
              if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                externalData_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.StringStringEntryProto>();
                mutable_bitField0_ |= 0x00000020;
              }
              externalData_.add(
                  input.readMessage(org.nd4j.ir.Nd4J.StringStringEntryProto.parser(), extensionRegistry));
              break;
            }
            case 112: {
              int rawValue = input.readEnum();

              dataLocation_ = rawValue;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          dims_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          floatData_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          int32Data_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          stringData_ = java.util.Collections.unmodifiableList(stringData_); // C
        }
        if (((mutable_bitField0_ & 0x00000010) != 0)) {
          int64Data_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000040) != 0)) {
          doubleData_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000080) != 0)) {
          uint64Data_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000020) != 0)) {
          externalData_ = java.util.Collections.unmodifiableList(externalData_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.TensorProto.class, org.nd4j.ir.Nd4J.TensorProto.Builder.class);
    }

    /**
     * <pre>
     * Location of the data for this tensor. MUST be one of:
     * - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
     * - EXTERNAL - data stored in an external location as described by external_data field.
     * </pre>
     *
     * Protobuf enum {@code org.nd4j.ir.TensorProto.DataLocation}
     */
    public enum DataLocation
        implements org.nd4j.shade.protobuf.ProtocolMessageEnum {
      /**
       * <code>DEFAULT = 0;</code>
       */
      DEFAULT(0),
      /**
       * <code>EXTERNAL = 1;</code>
       */
      EXTERNAL(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>DEFAULT = 0;</code>
       */
      public static final int DEFAULT_VALUE = 0;
      /**
       * <code>EXTERNAL = 1;</code>
       */
      public static final int EXTERNAL_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DataLocation valueOf(int value) {
        return forNumber(value);
      }

      public static DataLocation forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT;
          case 1: return EXTERNAL;
          default: return null;
        }
      }

      public static org.nd4j.shade.protobuf.Internal.EnumLiteMap<DataLocation>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final org.nd4j.shade.protobuf.Internal.EnumLiteMap<
          DataLocation> internalValueMap =
            new org.nd4j.shade.protobuf.Internal.EnumLiteMap<DataLocation>() {
              public DataLocation findValueByNumber(int number) {
                return DataLocation.forNumber(number);
              }
            };

      public final org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.TensorProto.getDescriptor().getEnumTypes().get(0);
      }

      private static final DataLocation[] VALUES = values();

      public static DataLocation valueOf(
          org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private DataLocation(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:org.nd4j.ir.TensorProto.DataLocation)
    }

    public interface SegmentOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.nd4j.ir.TensorProto.Segment)
        org.nd4j.shade.protobuf.MessageOrBuilder {

      /**
       * <code>int64 begin = 1;</code>
       */
      long getBegin();

      /**
       * <code>int64 end = 2;</code>
       */
      long getEnd();
    }
    /**
     * <pre>
     * For very large tensors, we may want to store them in chunks, in which
     * case the following fields will specify the segment that is stored in
     * the current TensorProto.
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.TensorProto.Segment}
     */
    public  static final class Segment extends
        org.nd4j.shade.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:org.nd4j.ir.TensorProto.Segment)
        SegmentOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Segment.newBuilder() to construct.
      private Segment(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Segment() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Segment();
      }

      @java.lang.Override
      public final org.nd4j.shade.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Segment(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
            org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {

                begin_ = input.readInt64();
                break;
              }
              case 16: {

                end_ = input.readInt64();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TensorProto.Segment.class, org.nd4j.ir.Nd4J.TensorProto.Segment.Builder.class);
      }

      public static final int BEGIN_FIELD_NUMBER = 1;
      private long begin_;
      /**
       * <code>int64 begin = 1;</code>
       */
      public long getBegin() {
        return begin_;
      }

      public static final int END_FIELD_NUMBER = 2;
      private long end_;
      /**
       * <code>int64 end = 2;</code>
       */
      public long getEnd() {
        return end_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (begin_ != 0L) {
          output.writeInt64(1, begin_);
        }
        if (end_ != 0L) {
          output.writeInt64(2, end_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (begin_ != 0L) {
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt64Size(1, begin_);
        }
        if (end_ != 0L) {
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt64Size(2, end_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.nd4j.ir.Nd4J.TensorProto.Segment)) {
          return super.equals(obj);
        }
        org.nd4j.ir.Nd4J.TensorProto.Segment other = (org.nd4j.ir.Nd4J.TensorProto.Segment) obj;

        if (getBegin()
            != other.getBegin()) return false;
        if (getEnd()
            != other.getEnd()) return false;
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + BEGIN_FIELD_NUMBER;
        hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong(
            getBegin());
        hash = (37 * hash) + END_FIELD_NUMBER;
        hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong(
            getEnd());
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          java.nio.ByteBuffer data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          java.nio.ByteBuffer data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          org.nd4j.shade.protobuf.ByteString data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          org.nd4j.shade.protobuf.ByteString data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(byte[] data)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          byte[] data,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseDelimitedFrom(
          java.io.InputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.nd4j.ir.Nd4J.TensorProto.Segment parseFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.nd4j.shade.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.nd4j.ir.Nd4J.TensorProto.Segment prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * For very large tensors, we may want to store them in chunks, in which
       * case the following fields will specify the segment that is stored in
       * the current TensorProto.
       * </pre>
       *
       * Protobuf type {@code org.nd4j.ir.TensorProto.Segment}
       */
      public static final class Builder extends
          org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TensorProto.Segment)
          org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder {
        public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor;
        }

        @java.lang.Override
        protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.nd4j.ir.Nd4J.TensorProto.Segment.class, org.nd4j.ir.Nd4J.TensorProto.Segment.Builder.class);
        }

        // Construct using org.nd4j.ir.Nd4J.TensorProto.Segment.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (org.nd4j.shade.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          begin_ = 0L;

          end_ = 0L;

          return this;
        }

        @java.lang.Override
        public org.nd4j.shade.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorProto.Segment getDefaultInstanceForType() {
          return org.nd4j.ir.Nd4J.TensorProto.Segment.getDefaultInstance();
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorProto.Segment build() {
          org.nd4j.ir.Nd4J.TensorProto.Segment result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.nd4j.ir.Nd4J.TensorProto.Segment buildPartial() {
          org.nd4j.ir.Nd4J.TensorProto.Segment result = new org.nd4j.ir.Nd4J.TensorProto.Segment(this);
          result.begin_ = begin_;
          result.end_ = end_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
          if (other instanceof org.nd4j.ir.Nd4J.TensorProto.Segment) {
            return mergeFrom((org.nd4j.ir.Nd4J.TensorProto.Segment)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.nd4j.ir.Nd4J.TensorProto.Segment other) {
          if (other == org.nd4j.ir.Nd4J.TensorProto.Segment.getDefaultInstance()) return this;
          if (other.getBegin() != 0L) {
            setBegin(other.getBegin());
          }
          if (other.getEnd() != 0L) {
            setEnd(other.getEnd());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.nd4j.ir.Nd4J.TensorProto.Segment parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.nd4j.ir.Nd4J.TensorProto.Segment) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private long begin_ ;
        /**
         * <code>int64 begin = 1;</code>
         */
        public long getBegin() {
          return begin_;
        }
        /**
         * <code>int64 begin = 1;</code>
         */
        public Builder setBegin(long value) {
          
          begin_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 begin = 1;</code>
         */
        public Builder clearBegin() {
          
          begin_ = 0L;
          onChanged();
          return this;
        }

        private long end_ ;
        /**
         * <code>int64 end = 2;</code>
         */
        public long getEnd() {
          return end_;
        }
        /**
         * <code>int64 end = 2;</code>
         */
        public Builder setEnd(long value) {
          
          end_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 end = 2;</code>
         */
        public Builder clearEnd() {
          
          end_ = 0L;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorProto.Segment)
      }

      // @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorProto.Segment)
      private static final org.nd4j.ir.Nd4J.TensorProto.Segment DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TensorProto.Segment();
      }

      public static org.nd4j.ir.Nd4J.TensorProto.Segment getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final org.nd4j.shade.protobuf.Parser<Segment>
          PARSER = new org.nd4j.shade.protobuf.AbstractParser<Segment>() {
        @java.lang.Override
        public Segment parsePartialFrom(
            org.nd4j.shade.protobuf.CodedInputStream input,
            org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
            throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
          return new Segment(input, extensionRegistry);
        }
      };

      public static org.nd4j.shade.protobuf.Parser<Segment> parser() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Parser<Segment> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorProto.Segment getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int DIMS_FIELD_NUMBER = 1;
    private org.nd4j.shade.protobuf.Internal.LongList dims_;
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    public java.util.List<java.lang.Long>
        getDimsList() {
      return dims_;
    }
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    public int getDimsCount() {
      return dims_.size();
    }
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     */
    public long getDims(int index) {
      return dims_.getLong(index);
    }
    private int dimsMemoizedSerializedSize = -1;

    public static final int DATA_TYPE_FIELD_NUMBER = 2;
    private int dataType_;
    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>int32 data_type = 2;</code>
     */
    public int getDataType() {
      return dataType_;
    }

    public static final int SEGMENT_FIELD_NUMBER = 3;
    private org.nd4j.ir.Nd4J.TensorProto.Segment segment_;
    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    public boolean hasSegment() {
      return segment_ != null;
    }
    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProto.Segment getSegment() {
      return segment_ == null ? org.nd4j.ir.Nd4J.TensorProto.Segment.getDefaultInstance() : segment_;
    }
    /**
     * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
      return getSegment();
    }

    public static final int FLOAT_DATA_FIELD_NUMBER = 4;
    private org.nd4j.shade.protobuf.Internal.FloatList floatData_;
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    public java.util.List<java.lang.Float>
        getFloatDataList() {
      return floatData_;
    }
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    public int getFloatDataCount() {
      return floatData_.size();
    }
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     */
    public float getFloatData(int index) {
      return floatData_.getFloat(index);
    }
    private int floatDataMemoizedSerializedSize = -1;

    public static final int INT32_DATA_FIELD_NUMBER = 5;
    private org.nd4j.shade.protobuf.Internal.IntList int32Data_;
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    public java.util.List<java.lang.Integer>
        getInt32DataList() {
      return int32Data_;
    }
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    public int getInt32DataCount() {
      return int32Data_.size();
    }
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    public int getInt32Data(int index) {
      return int32Data_.getInt(index);
    }
    private int int32DataMemoizedSerializedSize = -1;

    public static final int STRING_DATA_FIELD_NUMBER = 6;
    private java.util.List<org.nd4j.shade.protobuf.ByteString> stringData_;
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    public java.util.List<org.nd4j.shade.protobuf.ByteString>
        getStringDataList() {
      return stringData_;
    }
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    public int getStringDataCount() {
      return stringData_.size();
    }
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     */
    public org.nd4j.shade.protobuf.ByteString getStringData(int index) {
      return stringData_.get(index);
    }

    public static final int INT64_DATA_FIELD_NUMBER = 7;
    private org.nd4j.shade.protobuf.Internal.LongList int64Data_;
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    public java.util.List<java.lang.Long>
        getInt64DataList() {
      return int64Data_;
    }
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    public int getInt64DataCount() {
      return int64Data_.size();
    }
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    public long getInt64Data(int index) {
      return int64Data_.getLong(index);
    }
    private int int64DataMemoizedSerializedSize = -1;

    public static final int NAME_FIELD_NUMBER = 8;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>string name = 8;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>string name = 8;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    public static final int DOC_STRING_FIELD_NUMBER = 12;
    private volatile java.lang.Object docString_;
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 12;</code>
     */
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        docString_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>string doc_string = 12;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    public static final int RAW_DATA_FIELD_NUMBER = 9;
    private org.nd4j.shade.protobuf.ByteString rawData_;
    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>bytes raw_data = 9;</code>
     */
    public org.nd4j.shade.protobuf.ByteString getRawData() {
      return rawData_;
    }

    public static final int EXTERNAL_DATA_FIELD_NUMBER = 13;
    private java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto> externalData_;
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    public java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto> getExternalDataList() {
      return externalData_;
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    public java.util.List<? extends org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder> 
        getExternalDataOrBuilderList() {
      return externalData_;
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    public int getExternalDataCount() {
      return externalData_.size();
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    public org.nd4j.ir.Nd4J.StringStringEntryProto getExternalData(int index) {
      return externalData_.get(index);
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
     */
    public org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
        int index) {
      return externalData_.get(index);
    }

    public static final int DATA_LOCATION_FIELD_NUMBER = 14;
    private int dataLocation_;
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
     */
    public int getDataLocationValue() {
      return dataLocation_;
    }
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProto.DataLocation getDataLocation() {
      @SuppressWarnings("deprecation")
      org.nd4j.ir.Nd4J.TensorProto.DataLocation result = org.nd4j.ir.Nd4J.TensorProto.DataLocation.valueOf(dataLocation_);
      return result == null ? org.nd4j.ir.Nd4J.TensorProto.DataLocation.UNRECOGNIZED : result;
    }

    public static final int DOUBLE_DATA_FIELD_NUMBER = 10;
    private org.nd4j.shade.protobuf.Internal.DoubleList doubleData_;
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    public java.util.List<java.lang.Double>
        getDoubleDataList() {
      return doubleData_;
    }
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    public int getDoubleDataCount() {
      return doubleData_.size();
    }
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     */
    public double getDoubleData(int index) {
      return doubleData_.getDouble(index);
    }
    private int doubleDataMemoizedSerializedSize = -1;

    public static final int UINT64_DATA_FIELD_NUMBER = 11;
    private org.nd4j.shade.protobuf.Internal.LongList uint64Data_;
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    public java.util.List<java.lang.Long>
        getUint64DataList() {
      return uint64Data_;
    }
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    public int getUint64DataCount() {
      return uint64Data_.size();
    }
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    public long getUint64Data(int index) {
      return uint64Data_.getLong(index);
    }
    private int uint64DataMemoizedSerializedSize = -1;

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (getDimsList().size() > 0) {
        output.writeUInt32NoTag(10);
        output.writeUInt32NoTag(dimsMemoizedSerializedSize);
      }
      for (int i = 0; i < dims_.size(); i++) {
        output.writeInt64NoTag(dims_.getLong(i));
      }
      if (dataType_ != 0) {
        output.writeInt32(2, dataType_);
      }
      if (segment_ != null) {
        output.writeMessage(3, getSegment());
      }
      if (getFloatDataList().size() > 0) {
        output.writeUInt32NoTag(34);
        output.writeUInt32NoTag(floatDataMemoizedSerializedSize);
      }
      for (int i = 0; i < floatData_.size(); i++) {
        output.writeFloatNoTag(floatData_.getFloat(i));
      }
      if (getInt32DataList().size() > 0) {
        output.writeUInt32NoTag(42);
        output.writeUInt32NoTag(int32DataMemoizedSerializedSize);
      }
      for (int i = 0; i < int32Data_.size(); i++) {
        output.writeInt32NoTag(int32Data_.getInt(i));
      }
      for (int i = 0; i < stringData_.size(); i++) {
        output.writeBytes(6, stringData_.get(i));
      }
      if (getInt64DataList().size() > 0) {
        output.writeUInt32NoTag(58);
        output.writeUInt32NoTag(int64DataMemoizedSerializedSize);
      }
      for (int i = 0; i < int64Data_.size(); i++) {
        output.writeInt64NoTag(int64Data_.getLong(i));
      }
      if (!getNameBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 8, name_);
      }
      if (!rawData_.isEmpty()) {
        output.writeBytes(9, rawData_);
      }
      if (getDoubleDataList().size() > 0) {
        output.writeUInt32NoTag(82);
        output.writeUInt32NoTag(doubleDataMemoizedSerializedSize);
      }
      for (int i = 0; i < doubleData_.size(); i++) {
        output.writeDoubleNoTag(doubleData_.getDouble(i));
      }
      if (getUint64DataList().size() > 0) {
        output.writeUInt32NoTag(90);
        output.writeUInt32NoTag(uint64DataMemoizedSerializedSize);
      }
      for (int i = 0; i < uint64Data_.size(); i++) {
        output.writeUInt64NoTag(uint64Data_.getLong(i));
      }
      if (!getDocStringBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 12, docString_);
      }
      for (int i = 0; i < externalData_.size(); i++) {
        output.writeMessage(13, externalData_.get(i));
      }
      if (dataLocation_ != org.nd4j.ir.Nd4J.TensorProto.DataLocation.DEFAULT.getNumber()) {
        output.writeEnum(14, dataLocation_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dims_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(dims_.getLong(i));
        }
        size += dataSize;
        if (!getDimsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        dimsMemoizedSerializedSize = dataSize;
      }
      if (dataType_ != 0) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeInt32Size(2, dataType_);
      }
      if (segment_ != null) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(3, getSegment());
      }
      {
        int dataSize = 0;
        dataSize = 4 * getFloatDataList().size();
        size += dataSize;
        if (!getFloatDataList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        floatDataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < int32Data_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(int32Data_.getInt(i));
        }
        size += dataSize;
        if (!getInt32DataList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int32DataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < stringData_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(stringData_.get(i));
        }
        size += dataSize;
        size += 1 * getStringDataList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < int64Data_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(int64Data_.getLong(i));
        }
        size += dataSize;
        if (!getInt64DataList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int64DataMemoizedSerializedSize = dataSize;
      }
      if (!getNameBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(8, name_);
      }
      if (!rawData_.isEmpty()) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeBytesSize(9, rawData_);
      }
      {
        int dataSize = 0;
        dataSize = 8 * getDoubleDataList().size();
        size += dataSize;
        if (!getDoubleDataList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        doubleDataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < uint64Data_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(uint64Data_.getLong(i));
        }
        size += dataSize;
        if (!getUint64DataList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        uint64DataMemoizedSerializedSize = dataSize;
      }
      if (!getDocStringBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(12, docString_);
      }
      for (int i = 0; i < externalData_.size(); i++) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(13, externalData_.get(i));
      }
      if (dataLocation_ != org.nd4j.ir.Nd4J.TensorProto.DataLocation.DEFAULT.getNumber()) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeEnumSize(14, dataLocation_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.TensorProto)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.TensorProto other = (org.nd4j.ir.Nd4J.TensorProto) obj;

      if (!getDimsList()
          .equals(other.getDimsList())) return false;
      if (getDataType()
          != other.getDataType()) return false;
      if (hasSegment() != other.hasSegment()) return false;
      if (hasSegment()) {
        if (!getSegment()
            .equals(other.getSegment())) return false;
      }
      if (!getFloatDataList()
          .equals(other.getFloatDataList())) return false;
      if (!getInt32DataList()
          .equals(other.getInt32DataList())) return false;
      if (!getStringDataList()
          .equals(other.getStringDataList())) return false;
      if (!getInt64DataList()
          .equals(other.getInt64DataList())) return false;
      if (!getName()
          .equals(other.getName())) return false;
      if (!getDocString()
          .equals(other.getDocString())) return false;
      if (!getRawData()
          .equals(other.getRawData())) return false;
      if (!getExternalDataList()
          .equals(other.getExternalDataList())) return false;
      if (dataLocation_ != other.dataLocation_) return false;
      if (!getDoubleDataList()
          .equals(other.getDoubleDataList())) return false;
      if (!getUint64DataList()
          .equals(other.getUint64DataList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDimsCount() > 0) {
        hash = (37 * hash) + DIMS_FIELD_NUMBER;
        hash = (53 * hash) + getDimsList().hashCode();
      }
      hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getDataType();
      if (hasSegment()) {
        hash = (37 * hash) + SEGMENT_FIELD_NUMBER;
        hash = (53 * hash) + getSegment().hashCode();
      }
      if (getFloatDataCount() > 0) {
        hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getFloatDataList().hashCode();
      }
      if (getInt32DataCount() > 0) {
        hash = (37 * hash) + INT32_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getInt32DataList().hashCode();
      }
      if (getStringDataCount() > 0) {
        hash = (37 * hash) + STRING_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getStringDataList().hashCode();
      }
      if (getInt64DataCount() > 0) {
        hash = (37 * hash) + INT64_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getInt64DataList().hashCode();
      }
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
      hash = (53 * hash) + getDocString().hashCode();
      hash = (37 * hash) + RAW_DATA_FIELD_NUMBER;
      hash = (53 * hash) + getRawData().hashCode();
      if (getExternalDataCount() > 0) {
        hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getExternalDataList().hashCode();
      }
      hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER;
      hash = (53 * hash) + dataLocation_;
      if (getDoubleDataCount() > 0) {
        hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getDoubleDataList().hashCode();
      }
      if (getUint64DataCount() > 0) {
        hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getUint64DataList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.TensorProto parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.TensorProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Tensors
     * A serialized tensor value.
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.TensorProto}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.TensorProto)
        org.nd4j.ir.Nd4J.TensorProtoOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.TensorProto.class, org.nd4j.ir.Nd4J.TensorProto.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.TensorProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getExternalDataFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        dims_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000001);
        dataType_ = 0;

        if (segmentBuilder_ == null) {
          segment_ = null;
        } else {
          segment_ = null;
          segmentBuilder_ = null;
        }
        floatData_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        int32Data_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000004);
        stringData_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        int64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000010);
        name_ = "";

        docString_ = "";

        rawData_ = org.nd4j.shade.protobuf.ByteString.EMPTY;

        if (externalDataBuilder_ == null) {
          externalData_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          externalDataBuilder_.clear();
        }
        dataLocation_ = 0;

        doubleData_ = emptyDoubleList();
        bitField0_ = (bitField0_ & ~0x00000040);
        uint64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_TensorProto_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorProto getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorProto build() {
        org.nd4j.ir.Nd4J.TensorProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.TensorProto buildPartial() {
        org.nd4j.ir.Nd4J.TensorProto result = new org.nd4j.ir.Nd4J.TensorProto(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) != 0)) {
          dims_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.dims_ = dims_;
        result.dataType_ = dataType_;
        if (segmentBuilder_ == null) {
          result.segment_ = segment_;
        } else {
          result.segment_ = segmentBuilder_.build();
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          floatData_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.floatData_ = floatData_;
        if (((bitField0_ & 0x00000004) != 0)) {
          int32Data_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.int32Data_ = int32Data_;
        if (((bitField0_ & 0x00000008) != 0)) {
          stringData_ = java.util.Collections.unmodifiableList(stringData_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.stringData_ = stringData_;
        if (((bitField0_ & 0x00000010) != 0)) {
          int64Data_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.int64Data_ = int64Data_;
        result.name_ = name_;
        result.docString_ = docString_;
        result.rawData_ = rawData_;
        if (externalDataBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            externalData_ = java.util.Collections.unmodifiableList(externalData_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.externalData_ = externalData_;
        } else {
          result.externalData_ = externalDataBuilder_.build();
        }
        result.dataLocation_ = dataLocation_;
        if (((bitField0_ & 0x00000040) != 0)) {
          doubleData_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.doubleData_ = doubleData_;
        if (((bitField0_ & 0x00000080) != 0)) {
          uint64Data_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.uint64Data_ = uint64Data_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.TensorProto) {
          return mergeFrom((org.nd4j.ir.Nd4J.TensorProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.TensorProto other) {
        if (other == org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance()) return this;
        if (!other.dims_.isEmpty()) {
          if (dims_.isEmpty()) {
            dims_ = other.dims_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureDimsIsMutable();
            dims_.addAll(other.dims_);
          }
          onChanged();
        }
        if (other.getDataType() != 0) {
          setDataType(other.getDataType());
        }
        if (other.hasSegment()) {
          mergeSegment(other.getSegment());
        }
        if (!other.floatData_.isEmpty()) {
          if (floatData_.isEmpty()) {
            floatData_ = other.floatData_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureFloatDataIsMutable();
            floatData_.addAll(other.floatData_);
          }
          onChanged();
        }
        if (!other.int32Data_.isEmpty()) {
          if (int32Data_.isEmpty()) {
            int32Data_ = other.int32Data_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureInt32DataIsMutable();
            int32Data_.addAll(other.int32Data_);
          }
          onChanged();
        }
        if (!other.stringData_.isEmpty()) {
          if (stringData_.isEmpty()) {
            stringData_ = other.stringData_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureStringDataIsMutable();
            stringData_.addAll(other.stringData_);
          }
          onChanged();
        }
        if (!other.int64Data_.isEmpty()) {
          if (int64Data_.isEmpty()) {
            int64Data_ = other.int64Data_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureInt64DataIsMutable();
            int64Data_.addAll(other.int64Data_);
          }
          onChanged();
        }
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getDocString().isEmpty()) {
          docString_ = other.docString_;
          onChanged();
        }
        if (other.getRawData() != org.nd4j.shade.protobuf.ByteString.EMPTY) {
          setRawData(other.getRawData());
        }
        if (externalDataBuilder_ == null) {
          if (!other.externalData_.isEmpty()) {
            if (externalData_.isEmpty()) {
              externalData_ = other.externalData_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureExternalDataIsMutable();
              externalData_.addAll(other.externalData_);
            }
            onChanged();
          }
        } else {
          if (!other.externalData_.isEmpty()) {
            if (externalDataBuilder_.isEmpty()) {
              externalDataBuilder_.dispose();
              externalDataBuilder_ = null;
              externalData_ = other.externalData_;
              bitField0_ = (bitField0_ & ~0x00000020);
              externalDataBuilder_ = 
                org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExternalDataFieldBuilder() : null;
            } else {
              externalDataBuilder_.addAllMessages(other.externalData_);
            }
          }
        }
        if (other.dataLocation_ != 0) {
          setDataLocationValue(other.getDataLocationValue());
        }
        if (!other.doubleData_.isEmpty()) {
          if (doubleData_.isEmpty()) {
            doubleData_ = other.doubleData_;
            bitField0_ = (bitField0_ & ~0x00000040);
          } else {
            ensureDoubleDataIsMutable();
            doubleData_.addAll(other.doubleData_);
          }
          onChanged();
        }
        if (!other.uint64Data_.isEmpty()) {
          if (uint64Data_.isEmpty()) {
            uint64Data_ = other.uint64Data_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureUint64DataIsMutable();
            uint64Data_.addAll(other.uint64Data_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.TensorProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.TensorProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private org.nd4j.shade.protobuf.Internal.LongList dims_ = emptyLongList();
      private void ensureDimsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          dims_ = mutableCopy(dims_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public java.util.List<java.lang.Long>
          getDimsList() {
        return ((bitField0_ & 0x00000001) != 0) ?
                 java.util.Collections.unmodifiableList(dims_) : dims_;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public int getDimsCount() {
        return dims_.size();
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public long getDims(int index) {
        return dims_.getLong(index);
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public Builder setDims(
          int index, long value) {
        ensureDimsIsMutable();
        dims_.setLong(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public Builder addDims(long value) {
        ensureDimsIsMutable();
        dims_.addLong(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public Builder addAllDims(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureDimsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, dims_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       */
      public Builder clearDims() {
        dims_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private int dataType_ ;
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>int32 data_type = 2;</code>
       */
      public int getDataType() {
        return dataType_;
      }
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>int32 data_type = 2;</code>
       */
      public Builder setDataType(int value) {
        
        dataType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>int32 data_type = 2;</code>
       */
      public Builder clearDataType() {
        
        dataType_ = 0;
        onChanged();
        return this;
      }

      private org.nd4j.ir.Nd4J.TensorProto.Segment segment_;
      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto.Segment, org.nd4j.ir.Nd4J.TensorProto.Segment.Builder, org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder> segmentBuilder_;
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public boolean hasSegment() {
        return segmentBuilder_ != null || segment_ != null;
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Segment getSegment() {
        if (segmentBuilder_ == null) {
          return segment_ == null ? org.nd4j.ir.Nd4J.TensorProto.Segment.getDefaultInstance() : segment_;
        } else {
          return segmentBuilder_.getMessage();
        }
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public Builder setSegment(org.nd4j.ir.Nd4J.TensorProto.Segment value) {
        if (segmentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          segment_ = value;
          onChanged();
        } else {
          segmentBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public Builder setSegment(
          org.nd4j.ir.Nd4J.TensorProto.Segment.Builder builderForValue) {
        if (segmentBuilder_ == null) {
          segment_ = builderForValue.build();
          onChanged();
        } else {
          segmentBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public Builder mergeSegment(org.nd4j.ir.Nd4J.TensorProto.Segment value) {
        if (segmentBuilder_ == null) {
          if (segment_ != null) {
            segment_ =
              org.nd4j.ir.Nd4J.TensorProto.Segment.newBuilder(segment_).mergeFrom(value).buildPartial();
          } else {
            segment_ = value;
          }
          onChanged();
        } else {
          segmentBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public Builder clearSegment() {
        if (segmentBuilder_ == null) {
          segment_ = null;
          onChanged();
        } else {
          segment_ = null;
          segmentBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Segment.Builder getSegmentBuilder() {
        
        onChanged();
        return getSegmentFieldBuilder().getBuilder();
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
        if (segmentBuilder_ != null) {
          return segmentBuilder_.getMessageOrBuilder();
        } else {
          return segment_ == null ?
              org.nd4j.ir.Nd4J.TensorProto.Segment.getDefaultInstance() : segment_;
        }
      }
      /**
       * <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
       */
      private org.nd4j.shade.protobuf.SingleFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto.Segment, org.nd4j.ir.Nd4J.TensorProto.Segment.Builder, org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder> 
          getSegmentFieldBuilder() {
        if (segmentBuilder_ == null) {
          segmentBuilder_ = new org.nd4j.shade.protobuf.SingleFieldBuilderV3<
              org.nd4j.ir.Nd4J.TensorProto.Segment, org.nd4j.ir.Nd4J.TensorProto.Segment.Builder, org.nd4j.ir.Nd4J.TensorProto.SegmentOrBuilder>(
                  getSegment(),
                  getParentForChildren(),
                  isClean());
          segment_ = null;
        }
        return segmentBuilder_;
      }

      private org.nd4j.shade.protobuf.Internal.FloatList floatData_ = emptyFloatList();
      private void ensureFloatDataIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          floatData_ = mutableCopy(floatData_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public java.util.List<java.lang.Float>
          getFloatDataList() {
        return ((bitField0_ & 0x00000002) != 0) ?
                 java.util.Collections.unmodifiableList(floatData_) : floatData_;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public int getFloatDataCount() {
        return floatData_.size();
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public float getFloatData(int index) {
        return floatData_.getFloat(index);
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public Builder setFloatData(
          int index, float value) {
        ensureFloatDataIsMutable();
        floatData_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public Builder addFloatData(float value) {
        ensureFloatDataIsMutable();
        floatData_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public Builder addAllFloatData(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureFloatDataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, floatData_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       */
      public Builder clearFloatData() {
        floatData_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.IntList int32Data_ = emptyIntList();
      private void ensureInt32DataIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          int32Data_ = mutableCopy(int32Data_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public java.util.List<java.lang.Integer>
          getInt32DataList() {
        return ((bitField0_ & 0x00000004) != 0) ?
                 java.util.Collections.unmodifiableList(int32Data_) : int32Data_;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public int getInt32DataCount() {
        return int32Data_.size();
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public int getInt32Data(int index) {
        return int32Data_.getInt(index);
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public Builder setInt32Data(
          int index, int value) {
        ensureInt32DataIsMutable();
        int32Data_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public Builder addInt32Data(int value) {
        ensureInt32DataIsMutable();
        int32Data_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public Builder addAllInt32Data(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureInt32DataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, int32Data_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, bool, and float16 values
       * float16 values must be bit-wise converted to an uint16_t prior
       * to writing to the buffer.
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       */
      public Builder clearInt32Data() {
        int32Data_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      private java.util.List<org.nd4j.shade.protobuf.ByteString> stringData_ = java.util.Collections.emptyList();
      private void ensureStringDataIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          stringData_ = new java.util.ArrayList<org.nd4j.shade.protobuf.ByteString>(stringData_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public java.util.List<org.nd4j.shade.protobuf.ByteString>
          getStringDataList() {
        return ((bitField0_ & 0x00000008) != 0) ?
                 java.util.Collections.unmodifiableList(stringData_) : stringData_;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public int getStringDataCount() {
        return stringData_.size();
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public org.nd4j.shade.protobuf.ByteString getStringData(int index) {
        return stringData_.get(index);
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public Builder setStringData(
          int index, org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureStringDataIsMutable();
        stringData_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public Builder addStringData(org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureStringDataIsMutable();
        stringData_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public Builder addAllStringData(
          java.lang.Iterable<? extends org.nd4j.shade.protobuf.ByteString> values) {
        ensureStringDataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, stringData_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       */
      public Builder clearStringData() {
        stringData_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.LongList int64Data_ = emptyLongList();
      private void ensureInt64DataIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          int64Data_ = mutableCopy(int64Data_);
          bitField0_ |= 0x00000010;
         }
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public java.util.List<java.lang.Long>
          getInt64DataList() {
        return ((bitField0_ & 0x00000010) != 0) ?
                 java.util.Collections.unmodifiableList(int64Data_) : int64Data_;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public int getInt64DataCount() {
        return int64Data_.size();
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public long getInt64Data(int index) {
        return int64Data_.getLong(index);
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public Builder setInt64Data(
          int index, long value) {
        ensureInt64DataIsMutable();
        int64Data_.setLong(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public Builder addInt64Data(long value) {
        ensureInt64DataIsMutable();
        int64Data_.addLong(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public Builder addAllInt64Data(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureInt64DataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, int64Data_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       */
      public Builder clearInt64Data() {
        int64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>string name = 8;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>string name = 8;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>string name = 8;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>string name = 8;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>string name = 8;</code>
       */
      public Builder setNameBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 12;</code>
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          docString_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 12;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 12;</code>
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        docString_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 12;</code>
       */
      public Builder clearDocString() {
        
        docString_ = getDefaultInstance().getDocString();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>string doc_string = 12;</code>
       */
      public Builder setDocStringBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        docString_ = value;
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.ByteString rawData_ = org.nd4j.shade.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>bytes raw_data = 9;</code>
       */
      public org.nd4j.shade.protobuf.ByteString getRawData() {
        return rawData_;
      }
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>bytes raw_data = 9;</code>
       */
      public Builder setRawData(org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        rawData_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>bytes raw_data = 9;</code>
       */
      public Builder clearRawData() {
        
        rawData_ = getDefaultInstance().getRawData();
        onChanged();
        return this;
      }

      private java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto> externalData_ =
        java.util.Collections.emptyList();
      private void ensureExternalDataIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          externalData_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.StringStringEntryProto>(externalData_);
          bitField0_ |= 0x00000020;
         }
      }

      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.StringStringEntryProto, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder, org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder> externalDataBuilder_;

      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto> getExternalDataList() {
        if (externalDataBuilder_ == null) {
          return java.util.Collections.unmodifiableList(externalData_);
        } else {
          return externalDataBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public int getExternalDataCount() {
        if (externalDataBuilder_ == null) {
          return externalData_.size();
        } else {
          return externalDataBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public org.nd4j.ir.Nd4J.StringStringEntryProto getExternalData(int index) {
        if (externalDataBuilder_ == null) {
          return externalData_.get(index);
        } else {
          return externalDataBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder setExternalData(
          int index, org.nd4j.ir.Nd4J.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.set(index, value);
          onChanged();
        } else {
          externalDataBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder setExternalData(
          int index, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.set(index, builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(org.nd4j.ir.Nd4J.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.add(value);
          onChanged();
        } else {
          externalDataBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          int index, org.nd4j.ir.Nd4J.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.add(index, value);
          onChanged();
        } else {
          externalDataBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          org.nd4j.ir.Nd4J.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.add(builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          int index, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.add(index, builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder addAllExternalData(
          java.lang.Iterable<? extends org.nd4j.ir.Nd4J.StringStringEntryProto> values) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
              values, externalData_);
          onChanged();
        } else {
          externalDataBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder clearExternalData() {
        if (externalDataBuilder_ == null) {
          externalData_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          externalDataBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public Builder removeExternalData(int index) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.remove(index);
          onChanged();
        } else {
          externalDataBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public org.nd4j.ir.Nd4J.StringStringEntryProto.Builder getExternalDataBuilder(
          int index) {
        return getExternalDataFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
          int index) {
        if (externalDataBuilder_ == null) {
          return externalData_.get(index);  } else {
          return externalDataBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<? extends org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder> 
           getExternalDataOrBuilderList() {
        if (externalDataBuilder_ != null) {
          return externalDataBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(externalData_);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public org.nd4j.ir.Nd4J.StringStringEntryProto.Builder addExternalDataBuilder() {
        return getExternalDataFieldBuilder().addBuilder(
            org.nd4j.ir.Nd4J.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public org.nd4j.ir.Nd4J.StringStringEntryProto.Builder addExternalDataBuilder(
          int index) {
        return getExternalDataFieldBuilder().addBuilder(
            index, org.nd4j.ir.Nd4J.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       *                           protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.StringStringEntryProto.Builder> 
           getExternalDataBuilderList() {
        return getExternalDataFieldBuilder().getBuilderList();
      }
      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.StringStringEntryProto, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder, org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder> 
          getExternalDataFieldBuilder() {
        if (externalDataBuilder_ == null) {
          externalDataBuilder_ = new org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
              org.nd4j.ir.Nd4J.StringStringEntryProto, org.nd4j.ir.Nd4J.StringStringEntryProto.Builder, org.nd4j.ir.Nd4J.StringStringEntryProtoOrBuilder>(
                  externalData_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          externalData_ = null;
        }
        return externalDataBuilder_;
      }

      private int dataLocation_ = 0;
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
       */
      public int getDataLocationValue() {
        return dataLocation_;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
       */
      public Builder setDataLocationValue(int value) {
        dataLocation_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.DataLocation getDataLocation() {
        @SuppressWarnings("deprecation")
        org.nd4j.ir.Nd4J.TensorProto.DataLocation result = org.nd4j.ir.Nd4J.TensorProto.DataLocation.valueOf(dataLocation_);
        return result == null ? org.nd4j.ir.Nd4J.TensorProto.DataLocation.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
       */
      public Builder setDataLocation(org.nd4j.ir.Nd4J.TensorProto.DataLocation value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        dataLocation_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
       */
      public Builder clearDataLocation() {
        
        dataLocation_ = 0;
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.DoubleList doubleData_ = emptyDoubleList();
      private void ensureDoubleDataIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          doubleData_ = mutableCopy(doubleData_);
          bitField0_ |= 0x00000040;
         }
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public java.util.List<java.lang.Double>
          getDoubleDataList() {
        return ((bitField0_ & 0x00000040) != 0) ?
                 java.util.Collections.unmodifiableList(doubleData_) : doubleData_;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public int getDoubleDataCount() {
        return doubleData_.size();
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public double getDoubleData(int index) {
        return doubleData_.getDouble(index);
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public Builder setDoubleData(
          int index, double value) {
        ensureDoubleDataIsMutable();
        doubleData_.setDouble(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public Builder addDoubleData(double value) {
        ensureDoubleDataIsMutable();
        doubleData_.addDouble(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public Builder addAllDoubleData(
          java.lang.Iterable<? extends java.lang.Double> values) {
        ensureDoubleDataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, doubleData_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       */
      public Builder clearDoubleData() {
        doubleData_ = emptyDoubleList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.LongList uint64Data_ = emptyLongList();
      private void ensureUint64DataIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          uint64Data_ = mutableCopy(uint64Data_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public java.util.List<java.lang.Long>
          getUint64DataList() {
        return ((bitField0_ & 0x00000080) != 0) ?
                 java.util.Collections.unmodifiableList(uint64Data_) : uint64Data_;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public int getUint64DataCount() {
        return uint64Data_.size();
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public long getUint64Data(int index) {
        return uint64Data_.getLong(index);
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public Builder setUint64Data(
          int index, long value) {
        ensureUint64DataIsMutable();
        uint64Data_.setLong(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public Builder addUint64Data(long value) {
        ensureUint64DataIsMutable();
        uint64Data_.addLong(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public Builder addAllUint64Data(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureUint64DataIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, uint64Data_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       */
      public Builder clearUint64Data() {
        uint64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorProto)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorProto)
    private static final org.nd4j.ir.Nd4J.TensorProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.TensorProto();
    }

    public static org.nd4j.ir.Nd4J.TensorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<TensorProto>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<TensorProto>() {
      @java.lang.Override
      public TensorProto parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new TensorProto(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<TensorProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<TensorProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.TensorProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OpOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.nd4j.ir.Op)
      org.nd4j.shade.protobuf.MessageOrBuilder {

    /**
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <code>string name = 1;</code>
     */
    org.nd4j.shade.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    java.util.List<java.lang.Float> getFloatTArgsList();
    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    int getFloatTArgsCount();
    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    float getFloatTArgs(int index);

    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    java.util.List<java.lang.Float> getDoubleTArgsList();
    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    int getDoubleTArgsCount();
    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    float getDoubleTArgs(int index);

    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    java.util.List<java.lang.Integer> getIntArgsList();
    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    int getIntArgsCount();
    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    int getIntArgs(int index);

    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    java.util.List<java.lang.Integer> getInt64ArgsList();
    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    int getInt64ArgsCount();
    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    int getInt64Args(int index);

    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    java.util.List<java.lang.Boolean> getBoolArgsList();
    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    int getBoolArgsCount();
    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    boolean getBoolArgs(int index);

    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    java.util.List<org.nd4j.ir.Nd4J.DataType> getDataTypeArgsList();
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    int getDataTypeArgsCount();
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    org.nd4j.ir.Nd4J.DataType getDataTypeArgs(int index);
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    java.util.List<java.lang.Integer>
    getDataTypeArgsValueList();
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    int getDataTypeArgsValue(int index);

    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    java.util.List<org.nd4j.ir.Nd4J.TensorProto> 
        getInputsList();
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    org.nd4j.ir.Nd4J.TensorProto getInputs(int index);
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    int getInputsCount();
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
        getInputsOrBuilderList();
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    org.nd4j.ir.Nd4J.TensorProtoOrBuilder getInputsOrBuilder(
        int index);

    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    java.util.List<org.nd4j.ir.Nd4J.TensorProto> 
        getOutputsList();
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    org.nd4j.ir.Nd4J.TensorProto getOutputs(int index);
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    int getOutputsCount();
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
        getOutputsOrBuilderList();
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    org.nd4j.ir.Nd4J.TensorProtoOrBuilder getOutputsOrBuilder(
        int index);
  }
  /**
   * <pre>
   *Op descriptor
   * </pre>
   *
   * Protobuf type {@code org.nd4j.ir.Op}
   */
  public  static final class Op extends
      org.nd4j.shade.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:org.nd4j.ir.Op)
      OpOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Op.newBuilder() to construct.
    private Op(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Op() {
      name_ = "";
      floatTArgs_ = emptyFloatList();
      doubleTArgs_ = emptyFloatList();
      intArgs_ = emptyIntList();
      int64Args_ = emptyIntList();
      boolArgs_ = emptyBooleanList();
      dataTypeArgs_ = java.util.Collections.emptyList();
      inputs_ = java.util.Collections.emptyList();
      outputs_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Op();
    }

    @java.lang.Override
    public final org.nd4j.shade.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Op(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      org.nd4j.shade.protobuf.UnknownFieldSet.Builder unknownFields =
          org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 21: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                floatTArgs_ = newFloatList();
                mutable_bitField0_ |= 0x00000001;
              }
              floatTArgs_.addFloat(input.readFloat());
              break;
            }
            case 18: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
                floatTArgs_ = newFloatList();
                mutable_bitField0_ |= 0x00000001;
              }
              while (input.getBytesUntilLimit() > 0) {
                floatTArgs_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 29: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                doubleTArgs_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              doubleTArgs_.addFloat(input.readFloat());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000002) != 0) && input.getBytesUntilLimit() > 0) {
                doubleTArgs_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              while (input.getBytesUntilLimit() > 0) {
                doubleTArgs_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 32: {
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                intArgs_ = newIntList();
                mutable_bitField0_ |= 0x00000004;
              }
              intArgs_.addInt(input.readInt32());
              break;
            }
            case 34: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
                intArgs_ = newIntList();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                intArgs_.addInt(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 40: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                int64Args_ = newIntList();
                mutable_bitField0_ |= 0x00000008;
              }
              int64Args_.addInt(input.readInt32());
              break;
            }
            case 42: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000008) != 0) && input.getBytesUntilLimit() > 0) {
                int64Args_ = newIntList();
                mutable_bitField0_ |= 0x00000008;
              }
              while (input.getBytesUntilLimit() > 0) {
                int64Args_.addInt(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 48: {
              if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                boolArgs_ = newBooleanList();
                mutable_bitField0_ |= 0x00000010;
              }
              boolArgs_.addBoolean(input.readBool());
              break;
            }
            case 50: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000010) != 0) && input.getBytesUntilLimit() > 0) {
                boolArgs_ = newBooleanList();
                mutable_bitField0_ |= 0x00000010;
              }
              while (input.getBytesUntilLimit() > 0) {
                boolArgs_.addBoolean(input.readBool());
              }
              input.popLimit(limit);
              break;
            }
            case 56: {
              int rawValue = input.readEnum();
              if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                dataTypeArgs_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000020;
              }
              dataTypeArgs_.add(rawValue);
              break;
            }
            case 58: {
              int length = input.readRawVarint32();
              int oldLimit = input.pushLimit(length);
              while(input.getBytesUntilLimit() > 0) {
                int rawValue = input.readEnum();
                if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                  dataTypeArgs_ = new java.util.ArrayList<java.lang.Integer>();
                  mutable_bitField0_ |= 0x00000020;
                }
                dataTypeArgs_.add(rawValue);
              }
              input.popLimit(oldLimit);
              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000040) != 0)) {
                inputs_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorProto>();
                mutable_bitField0_ |= 0x00000040;
              }
              inputs_.add(
                  input.readMessage(org.nd4j.ir.Nd4J.TensorProto.parser(), extensionRegistry));
              break;
            }
            case 74: {
              if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                outputs_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorProto>();
                mutable_bitField0_ |= 0x00000080;
              }
              outputs_.add(
                  input.readMessage(org.nd4j.ir.Nd4J.TensorProto.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new org.nd4j.shade.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          floatTArgs_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          doubleTArgs_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          intArgs_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          int64Args_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000010) != 0)) {
          boolArgs_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000020) != 0)) {
          dataTypeArgs_ = java.util.Collections.unmodifiableList(dataTypeArgs_);
        }
        if (((mutable_bitField0_ & 0x00000040) != 0)) {
          inputs_ = java.util.Collections.unmodifiableList(inputs_);
        }
        if (((mutable_bitField0_ & 0x00000080) != 0)) {
          outputs_ = java.util.Collections.unmodifiableList(outputs_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_Op_descriptor;
    }

    @java.lang.Override
    protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_Op_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.nd4j.ir.Nd4J.Op.class, org.nd4j.ir.Nd4J.Op.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        org.nd4j.shade.protobuf.ByteString bs = 
            (org.nd4j.shade.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <code>string name = 1;</code>
     */
    public org.nd4j.shade.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        org.nd4j.shade.protobuf.ByteString b = 
            org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (org.nd4j.shade.protobuf.ByteString) ref;
      }
    }

    public static final int FLOATTARGS_FIELD_NUMBER = 2;
    private org.nd4j.shade.protobuf.Internal.FloatList floatTArgs_;
    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    public java.util.List<java.lang.Float>
        getFloatTArgsList() {
      return floatTArgs_;
    }
    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    public int getFloatTArgsCount() {
      return floatTArgs_.size();
    }
    /**
     * <pre>
     * t args
     * </pre>
     *
     * <code>repeated float floatTArgs = 2;</code>
     */
    public float getFloatTArgs(int index) {
      return floatTArgs_.getFloat(index);
    }
    private int floatTArgsMemoizedSerializedSize = -1;

    public static final int DOUBLETARGS_FIELD_NUMBER = 3;
    private org.nd4j.shade.protobuf.Internal.FloatList doubleTArgs_;
    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    public java.util.List<java.lang.Float>
        getDoubleTArgsList() {
      return doubleTArgs_;
    }
    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    public int getDoubleTArgsCount() {
      return doubleTArgs_.size();
    }
    /**
     * <code>repeated float doubleTArgs = 3;</code>
     */
    public float getDoubleTArgs(int index) {
      return doubleTArgs_.getFloat(index);
    }
    private int doubleTArgsMemoizedSerializedSize = -1;

    public static final int INTARGS_FIELD_NUMBER = 4;
    private org.nd4j.shade.protobuf.Internal.IntList intArgs_;
    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    public java.util.List<java.lang.Integer>
        getIntArgsList() {
      return intArgs_;
    }
    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    public int getIntArgsCount() {
      return intArgs_.size();
    }
    /**
     * <pre>
     *iArgs
     * </pre>
     *
     * <code>repeated int32 intArgs = 4;</code>
     */
    public int getIntArgs(int index) {
      return intArgs_.getInt(index);
    }
    private int intArgsMemoizedSerializedSize = -1;

    public static final int INT64ARGS_FIELD_NUMBER = 5;
    private org.nd4j.shade.protobuf.Internal.IntList int64Args_;
    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    public java.util.List<java.lang.Integer>
        getInt64ArgsList() {
      return int64Args_;
    }
    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    public int getInt64ArgsCount() {
      return int64Args_.size();
    }
    /**
     * <code>repeated int32 int64Args = 5;</code>
     */
    public int getInt64Args(int index) {
      return int64Args_.getInt(index);
    }
    private int int64ArgsMemoizedSerializedSize = -1;

    public static final int BOOLARGS_FIELD_NUMBER = 6;
    private org.nd4j.shade.protobuf.Internal.BooleanList boolArgs_;
    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    public java.util.List<java.lang.Boolean>
        getBoolArgsList() {
      return boolArgs_;
    }
    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    public int getBoolArgsCount() {
      return boolArgs_.size();
    }
    /**
     * <pre>
     *boolArgs
     * </pre>
     *
     * <code>repeated bool boolArgs = 6;</code>
     */
    public boolean getBoolArgs(int index) {
      return boolArgs_.getBoolean(index);
    }
    private int boolArgsMemoizedSerializedSize = -1;

    public static final int DATATYPEARGS_FIELD_NUMBER = 7;
    private java.util.List<java.lang.Integer> dataTypeArgs_;
    private static final org.nd4j.shade.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.nd4j.ir.Nd4J.DataType> dataTypeArgs_converter_ =
            new org.nd4j.shade.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.nd4j.ir.Nd4J.DataType>() {
              public org.nd4j.ir.Nd4J.DataType convert(java.lang.Integer from) {
                @SuppressWarnings("deprecation")
                org.nd4j.ir.Nd4J.DataType result = org.nd4j.ir.Nd4J.DataType.valueOf(from);
                return result == null ? org.nd4j.ir.Nd4J.DataType.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    public java.util.List<org.nd4j.ir.Nd4J.DataType> getDataTypeArgsList() {
      return new org.nd4j.shade.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.nd4j.ir.Nd4J.DataType>(dataTypeArgs_, dataTypeArgs_converter_);
    }
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    public int getDataTypeArgsCount() {
      return dataTypeArgs_.size();
    }
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    public org.nd4j.ir.Nd4J.DataType getDataTypeArgs(int index) {
      return dataTypeArgs_converter_.convert(dataTypeArgs_.get(index));
    }
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    public java.util.List<java.lang.Integer>
    getDataTypeArgsValueList() {
      return dataTypeArgs_;
    }
    /**
     * <pre>
     * data type args
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
     */
    public int getDataTypeArgsValue(int index) {
      return dataTypeArgs_.get(index);
    }
    private int dataTypeArgsMemoizedSerializedSize;

    public static final int INPUTS_FIELD_NUMBER = 8;
    private java.util.List<org.nd4j.ir.Nd4J.TensorProto> inputs_;
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    public java.util.List<org.nd4j.ir.Nd4J.TensorProto> getInputsList() {
      return inputs_;
    }
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    public java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
        getInputsOrBuilderList() {
      return inputs_;
    }
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    public int getInputsCount() {
      return inputs_.size();
    }
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProto getInputs(int index) {
      return inputs_.get(index);
    }
    /**
     * <pre>
     *inputs and output ndarrays
     * </pre>
     *
     * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProtoOrBuilder getInputsOrBuilder(
        int index) {
      return inputs_.get(index);
    }

    public static final int OUTPUTS_FIELD_NUMBER = 9;
    private java.util.List<org.nd4j.ir.Nd4J.TensorProto> outputs_;
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    public java.util.List<org.nd4j.ir.Nd4J.TensorProto> getOutputsList() {
      return outputs_;
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    public java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
        getOutputsOrBuilderList() {
      return outputs_;
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    public int getOutputsCount() {
      return outputs_.size();
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProto getOutputs(int index) {
      return outputs_.get(index);
    }
    /**
     * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
     */
    public org.nd4j.ir.Nd4J.TensorProtoOrBuilder getOutputsOrBuilder(
        int index) {
      return outputs_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (!getNameBytes().isEmpty()) {
        org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (getFloatTArgsList().size() > 0) {
        output.writeUInt32NoTag(18);
        output.writeUInt32NoTag(floatTArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < floatTArgs_.size(); i++) {
        output.writeFloatNoTag(floatTArgs_.getFloat(i));
      }
      if (getDoubleTArgsList().size() > 0) {
        output.writeUInt32NoTag(26);
        output.writeUInt32NoTag(doubleTArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < doubleTArgs_.size(); i++) {
        output.writeFloatNoTag(doubleTArgs_.getFloat(i));
      }
      if (getIntArgsList().size() > 0) {
        output.writeUInt32NoTag(34);
        output.writeUInt32NoTag(intArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < intArgs_.size(); i++) {
        output.writeInt32NoTag(intArgs_.getInt(i));
      }
      if (getInt64ArgsList().size() > 0) {
        output.writeUInt32NoTag(42);
        output.writeUInt32NoTag(int64ArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < int64Args_.size(); i++) {
        output.writeInt32NoTag(int64Args_.getInt(i));
      }
      if (getBoolArgsList().size() > 0) {
        output.writeUInt32NoTag(50);
        output.writeUInt32NoTag(boolArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < boolArgs_.size(); i++) {
        output.writeBoolNoTag(boolArgs_.getBoolean(i));
      }
      if (getDataTypeArgsList().size() > 0) {
        output.writeUInt32NoTag(58);
        output.writeUInt32NoTag(dataTypeArgsMemoizedSerializedSize);
      }
      for (int i = 0; i < dataTypeArgs_.size(); i++) {
        output.writeEnumNoTag(dataTypeArgs_.get(i));
      }
      for (int i = 0; i < inputs_.size(); i++) {
        output.writeMessage(8, inputs_.get(i));
      }
      for (int i = 0; i < outputs_.size(); i++) {
        output.writeMessage(9, outputs_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getFloatTArgsList().size();
        size += dataSize;
        if (!getFloatTArgsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        floatTArgsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        dataSize = 4 * getDoubleTArgsList().size();
        size += dataSize;
        if (!getDoubleTArgsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        doubleTArgsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < intArgs_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(intArgs_.getInt(i));
        }
        size += dataSize;
        if (!getIntArgsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        intArgsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < int64Args_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(int64Args_.getInt(i));
        }
        size += dataSize;
        if (!getInt64ArgsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int64ArgsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        dataSize = 1 * getBoolArgsList().size();
        size += dataSize;
        if (!getBoolArgsList().isEmpty()) {
          size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        boolArgsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < dataTypeArgs_.size(); i++) {
          dataSize += org.nd4j.shade.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(dataTypeArgs_.get(i));
        }
        size += dataSize;
        if (!getDataTypeArgsList().isEmpty()) {  size += 1;
          size += org.nd4j.shade.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(dataSize);
        }dataTypeArgsMemoizedSerializedSize = dataSize;
      }
      for (int i = 0; i < inputs_.size(); i++) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(8, inputs_.get(i));
      }
      for (int i = 0; i < outputs_.size(); i++) {
        size += org.nd4j.shade.protobuf.CodedOutputStream
          .computeMessageSize(9, outputs_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.nd4j.ir.Nd4J.Op)) {
        return super.equals(obj);
      }
      org.nd4j.ir.Nd4J.Op other = (org.nd4j.ir.Nd4J.Op) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getFloatTArgsList()
          .equals(other.getFloatTArgsList())) return false;
      if (!getDoubleTArgsList()
          .equals(other.getDoubleTArgsList())) return false;
      if (!getIntArgsList()
          .equals(other.getIntArgsList())) return false;
      if (!getInt64ArgsList()
          .equals(other.getInt64ArgsList())) return false;
      if (!getBoolArgsList()
          .equals(other.getBoolArgsList())) return false;
      if (!dataTypeArgs_.equals(other.dataTypeArgs_)) return false;
      if (!getInputsList()
          .equals(other.getInputsList())) return false;
      if (!getOutputsList()
          .equals(other.getOutputsList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (getFloatTArgsCount() > 0) {
        hash = (37 * hash) + FLOATTARGS_FIELD_NUMBER;
        hash = (53 * hash) + getFloatTArgsList().hashCode();
      }
      if (getDoubleTArgsCount() > 0) {
        hash = (37 * hash) + DOUBLETARGS_FIELD_NUMBER;
        hash = (53 * hash) + getDoubleTArgsList().hashCode();
      }
      if (getIntArgsCount() > 0) {
        hash = (37 * hash) + INTARGS_FIELD_NUMBER;
        hash = (53 * hash) + getIntArgsList().hashCode();
      }
      if (getInt64ArgsCount() > 0) {
        hash = (37 * hash) + INT64ARGS_FIELD_NUMBER;
        hash = (53 * hash) + getInt64ArgsList().hashCode();
      }
      if (getBoolArgsCount() > 0) {
        hash = (37 * hash) + BOOLARGS_FIELD_NUMBER;
        hash = (53 * hash) + getBoolArgsList().hashCode();
      }
      if (getDataTypeArgsCount() > 0) {
        hash = (37 * hash) + DATATYPEARGS_FIELD_NUMBER;
        hash = (53 * hash) + dataTypeArgs_.hashCode();
      }
      if (getInputsCount() > 0) {
        hash = (37 * hash) + INPUTS_FIELD_NUMBER;
        hash = (53 * hash) + getInputsList().hashCode();
      }
      if (getOutputsCount() > 0) {
        hash = (37 * hash) + OUTPUTS_FIELD_NUMBER;
        hash = (53 * hash) + getOutputsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.nd4j.ir.Nd4J.Op parseFrom(
        java.nio.ByteBuffer data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        java.nio.ByteBuffer data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        org.nd4j.shade.protobuf.ByteString data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        org.nd4j.shade.protobuf.ByteString data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(byte[] data)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        byte[] data,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.Op parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.Op parseDelimitedFrom(
        java.io.InputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.nd4j.ir.Nd4J.Op parseFrom(
        org.nd4j.shade.protobuf.CodedInputStream input,
        org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.nd4j.shade.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.nd4j.ir.Nd4J.Op prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     *Op descriptor
     * </pre>
     *
     * Protobuf type {@code org.nd4j.ir.Op}
     */
    public static final class Builder extends
        org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:org.nd4j.ir.Op)
        org.nd4j.ir.Nd4J.OpOrBuilder {
      public static final org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_Op_descriptor;
      }

      @java.lang.Override
      protected org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_Op_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.nd4j.ir.Nd4J.Op.class, org.nd4j.ir.Nd4J.Op.Builder.class);
      }

      // Construct using org.nd4j.ir.Nd4J.Op.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (org.nd4j.shade.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getInputsFieldBuilder();
          getOutputsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        floatTArgs_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000001);
        doubleTArgs_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        intArgs_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000004);
        int64Args_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000008);
        boolArgs_ = emptyBooleanList();
        bitField0_ = (bitField0_ & ~0x00000010);
        dataTypeArgs_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        if (inputsBuilder_ == null) {
          inputs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          inputsBuilder_.clear();
        }
        if (outputsBuilder_ == null) {
          outputs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
        } else {
          outputsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public org.nd4j.shade.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.nd4j.ir.Nd4J.internal_static_org_nd4j_ir_Op_descriptor;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.Op getDefaultInstanceForType() {
        return org.nd4j.ir.Nd4J.Op.getDefaultInstance();
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.Op build() {
        org.nd4j.ir.Nd4J.Op result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.nd4j.ir.Nd4J.Op buildPartial() {
        org.nd4j.ir.Nd4J.Op result = new org.nd4j.ir.Nd4J.Op(this);
        int from_bitField0_ = bitField0_;
        result.name_ = name_;
        if (((bitField0_ & 0x00000001) != 0)) {
          floatTArgs_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.floatTArgs_ = floatTArgs_;
        if (((bitField0_ & 0x00000002) != 0)) {
          doubleTArgs_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.doubleTArgs_ = doubleTArgs_;
        if (((bitField0_ & 0x00000004) != 0)) {
          intArgs_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.intArgs_ = intArgs_;
        if (((bitField0_ & 0x00000008) != 0)) {
          int64Args_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.int64Args_ = int64Args_;
        if (((bitField0_ & 0x00000010) != 0)) {
          boolArgs_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.boolArgs_ = boolArgs_;
        if (((bitField0_ & 0x00000020) != 0)) {
          dataTypeArgs_ = java.util.Collections.unmodifiableList(dataTypeArgs_);
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.dataTypeArgs_ = dataTypeArgs_;
        if (inputsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            inputs_ = java.util.Collections.unmodifiableList(inputs_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.inputs_ = inputs_;
        } else {
          result.inputs_ = inputsBuilder_.build();
        }
        if (outputsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            outputs_ = java.util.Collections.unmodifiableList(outputs_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.outputs_ = outputs_;
        } else {
          result.outputs_ = outputsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          org.nd4j.shade.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          org.nd4j.shade.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(org.nd4j.shade.protobuf.Message other) {
        if (other instanceof org.nd4j.ir.Nd4J.Op) {
          return mergeFrom((org.nd4j.ir.Nd4J.Op)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.nd4j.ir.Nd4J.Op other) {
        if (other == org.nd4j.ir.Nd4J.Op.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.floatTArgs_.isEmpty()) {
          if (floatTArgs_.isEmpty()) {
            floatTArgs_ = other.floatTArgs_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureFloatTArgsIsMutable();
            floatTArgs_.addAll(other.floatTArgs_);
          }
          onChanged();
        }
        if (!other.doubleTArgs_.isEmpty()) {
          if (doubleTArgs_.isEmpty()) {
            doubleTArgs_ = other.doubleTArgs_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureDoubleTArgsIsMutable();
            doubleTArgs_.addAll(other.doubleTArgs_);
          }
          onChanged();
        }
        if (!other.intArgs_.isEmpty()) {
          if (intArgs_.isEmpty()) {
            intArgs_ = other.intArgs_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureIntArgsIsMutable();
            intArgs_.addAll(other.intArgs_);
          }
          onChanged();
        }
        if (!other.int64Args_.isEmpty()) {
          if (int64Args_.isEmpty()) {
            int64Args_ = other.int64Args_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureInt64ArgsIsMutable();
            int64Args_.addAll(other.int64Args_);
          }
          onChanged();
        }
        if (!other.boolArgs_.isEmpty()) {
          if (boolArgs_.isEmpty()) {
            boolArgs_ = other.boolArgs_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureBoolArgsIsMutable();
            boolArgs_.addAll(other.boolArgs_);
          }
          onChanged();
        }
        if (!other.dataTypeArgs_.isEmpty()) {
          if (dataTypeArgs_.isEmpty()) {
            dataTypeArgs_ = other.dataTypeArgs_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureDataTypeArgsIsMutable();
            dataTypeArgs_.addAll(other.dataTypeArgs_);
          }
          onChanged();
        }
        if (inputsBuilder_ == null) {
          if (!other.inputs_.isEmpty()) {
            if (inputs_.isEmpty()) {
              inputs_ = other.inputs_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureInputsIsMutable();
              inputs_.addAll(other.inputs_);
            }
            onChanged();
          }
        } else {
          if (!other.inputs_.isEmpty()) {
            if (inputsBuilder_.isEmpty()) {
              inputsBuilder_.dispose();
              inputsBuilder_ = null;
              inputs_ = other.inputs_;
              bitField0_ = (bitField0_ & ~0x00000040);
              inputsBuilder_ = 
                org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInputsFieldBuilder() : null;
            } else {
              inputsBuilder_.addAllMessages(other.inputs_);
            }
          }
        }
        if (outputsBuilder_ == null) {
          if (!other.outputs_.isEmpty()) {
            if (outputs_.isEmpty()) {
              outputs_ = other.outputs_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureOutputsIsMutable();
              outputs_.addAll(other.outputs_);
            }
            onChanged();
          }
        } else {
          if (!other.outputs_.isEmpty()) {
            if (outputsBuilder_.isEmpty()) {
              outputsBuilder_.dispose();
              outputsBuilder_ = null;
              outputs_ = other.outputs_;
              bitField0_ = (bitField0_ & ~0x00000080);
              outputsBuilder_ = 
                org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getOutputsFieldBuilder() : null;
            } else {
              outputsBuilder_.addAllMessages(other.outputs_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.nd4j.ir.Nd4J.Op parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (org.nd4j.shade.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.nd4j.ir.Nd4J.Op) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          org.nd4j.shade.protobuf.ByteString bs =
              (org.nd4j.shade.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       */
      public org.nd4j.shade.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          org.nd4j.shade.protobuf.ByteString b = 
              org.nd4j.shade.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (org.nd4j.shade.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          org.nd4j.shade.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.FloatList floatTArgs_ = emptyFloatList();
      private void ensureFloatTArgsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          floatTArgs_ = mutableCopy(floatTArgs_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public java.util.List<java.lang.Float>
          getFloatTArgsList() {
        return ((bitField0_ & 0x00000001) != 0) ?
                 java.util.Collections.unmodifiableList(floatTArgs_) : floatTArgs_;
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public int getFloatTArgsCount() {
        return floatTArgs_.size();
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public float getFloatTArgs(int index) {
        return floatTArgs_.getFloat(index);
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public Builder setFloatTArgs(
          int index, float value) {
        ensureFloatTArgsIsMutable();
        floatTArgs_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public Builder addFloatTArgs(float value) {
        ensureFloatTArgsIsMutable();
        floatTArgs_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public Builder addAllFloatTArgs(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureFloatTArgsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, floatTArgs_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * t args
       * </pre>
       *
       * <code>repeated float floatTArgs = 2;</code>
       */
      public Builder clearFloatTArgs() {
        floatTArgs_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.FloatList doubleTArgs_ = emptyFloatList();
      private void ensureDoubleTArgsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          doubleTArgs_ = mutableCopy(doubleTArgs_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public java.util.List<java.lang.Float>
          getDoubleTArgsList() {
        return ((bitField0_ & 0x00000002) != 0) ?
                 java.util.Collections.unmodifiableList(doubleTArgs_) : doubleTArgs_;
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public int getDoubleTArgsCount() {
        return doubleTArgs_.size();
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public float getDoubleTArgs(int index) {
        return doubleTArgs_.getFloat(index);
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public Builder setDoubleTArgs(
          int index, float value) {
        ensureDoubleTArgsIsMutable();
        doubleTArgs_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public Builder addDoubleTArgs(float value) {
        ensureDoubleTArgsIsMutable();
        doubleTArgs_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public Builder addAllDoubleTArgs(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureDoubleTArgsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, doubleTArgs_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float doubleTArgs = 3;</code>
       */
      public Builder clearDoubleTArgs() {
        doubleTArgs_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.IntList intArgs_ = emptyIntList();
      private void ensureIntArgsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          intArgs_ = mutableCopy(intArgs_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public java.util.List<java.lang.Integer>
          getIntArgsList() {
        return ((bitField0_ & 0x00000004) != 0) ?
                 java.util.Collections.unmodifiableList(intArgs_) : intArgs_;
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public int getIntArgsCount() {
        return intArgs_.size();
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public int getIntArgs(int index) {
        return intArgs_.getInt(index);
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public Builder setIntArgs(
          int index, int value) {
        ensureIntArgsIsMutable();
        intArgs_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public Builder addIntArgs(int value) {
        ensureIntArgsIsMutable();
        intArgs_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public Builder addAllIntArgs(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureIntArgsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, intArgs_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *iArgs
       * </pre>
       *
       * <code>repeated int32 intArgs = 4;</code>
       */
      public Builder clearIntArgs() {
        intArgs_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.IntList int64Args_ = emptyIntList();
      private void ensureInt64ArgsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          int64Args_ = mutableCopy(int64Args_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public java.util.List<java.lang.Integer>
          getInt64ArgsList() {
        return ((bitField0_ & 0x00000008) != 0) ?
                 java.util.Collections.unmodifiableList(int64Args_) : int64Args_;
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public int getInt64ArgsCount() {
        return int64Args_.size();
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public int getInt64Args(int index) {
        return int64Args_.getInt(index);
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public Builder setInt64Args(
          int index, int value) {
        ensureInt64ArgsIsMutable();
        int64Args_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public Builder addInt64Args(int value) {
        ensureInt64ArgsIsMutable();
        int64Args_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public Builder addAllInt64Args(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureInt64ArgsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, int64Args_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 int64Args = 5;</code>
       */
      public Builder clearInt64Args() {
        int64Args_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private org.nd4j.shade.protobuf.Internal.BooleanList boolArgs_ = emptyBooleanList();
      private void ensureBoolArgsIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          boolArgs_ = mutableCopy(boolArgs_);
          bitField0_ |= 0x00000010;
         }
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public java.util.List<java.lang.Boolean>
          getBoolArgsList() {
        return ((bitField0_ & 0x00000010) != 0) ?
                 java.util.Collections.unmodifiableList(boolArgs_) : boolArgs_;
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public int getBoolArgsCount() {
        return boolArgs_.size();
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public boolean getBoolArgs(int index) {
        return boolArgs_.getBoolean(index);
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public Builder setBoolArgs(
          int index, boolean value) {
        ensureBoolArgsIsMutable();
        boolArgs_.setBoolean(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public Builder addBoolArgs(boolean value) {
        ensureBoolArgsIsMutable();
        boolArgs_.addBoolean(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public Builder addAllBoolArgs(
          java.lang.Iterable<? extends java.lang.Boolean> values) {
        ensureBoolArgsIsMutable();
        org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
            values, boolArgs_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *boolArgs
       * </pre>
       *
       * <code>repeated bool boolArgs = 6;</code>
       */
      public Builder clearBoolArgs() {
        boolArgs_ = emptyBooleanList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> dataTypeArgs_ =
        java.util.Collections.emptyList();
      private void ensureDataTypeArgsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          dataTypeArgs_ = new java.util.ArrayList<java.lang.Integer>(dataTypeArgs_);
          bitField0_ |= 0x00000020;
        }
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.DataType> getDataTypeArgsList() {
        return new org.nd4j.shade.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.nd4j.ir.Nd4J.DataType>(dataTypeArgs_, dataTypeArgs_converter_);
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public int getDataTypeArgsCount() {
        return dataTypeArgs_.size();
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public org.nd4j.ir.Nd4J.DataType getDataTypeArgs(int index) {
        return dataTypeArgs_converter_.convert(dataTypeArgs_.get(index));
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder setDataTypeArgs(
          int index, org.nd4j.ir.Nd4J.DataType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDataTypeArgsIsMutable();
        dataTypeArgs_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder addDataTypeArgs(org.nd4j.ir.Nd4J.DataType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDataTypeArgsIsMutable();
        dataTypeArgs_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder addAllDataTypeArgs(
          java.lang.Iterable<? extends org.nd4j.ir.Nd4J.DataType> values) {
        ensureDataTypeArgsIsMutable();
        for (org.nd4j.ir.Nd4J.DataType value : values) {
          dataTypeArgs_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder clearDataTypeArgs() {
        dataTypeArgs_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public java.util.List<java.lang.Integer>
      getDataTypeArgsValueList() {
        return java.util.Collections.unmodifiableList(dataTypeArgs_);
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public int getDataTypeArgsValue(int index) {
        return dataTypeArgs_.get(index);
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder setDataTypeArgsValue(
          int index, int value) {
        ensureDataTypeArgsIsMutable();
        dataTypeArgs_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder addDataTypeArgsValue(int value) {
        ensureDataTypeArgsIsMutable();
        dataTypeArgs_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * data type args
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.DataType dataTypeArgs = 7;</code>
       */
      public Builder addAllDataTypeArgsValue(
          java.lang.Iterable<java.lang.Integer> values) {
        ensureDataTypeArgsIsMutable();
        for (int value : values) {
          dataTypeArgs_.add(value);
        }
        onChanged();
        return this;
      }

      private java.util.List<org.nd4j.ir.Nd4J.TensorProto> inputs_ =
        java.util.Collections.emptyList();
      private void ensureInputsIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          inputs_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorProto>(inputs_);
          bitField0_ |= 0x00000040;
         }
      }

      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder> inputsBuilder_;

      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorProto> getInputsList() {
        if (inputsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(inputs_);
        } else {
          return inputsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public int getInputsCount() {
        if (inputsBuilder_ == null) {
          return inputs_.size();
        } else {
          return inputsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto getInputs(int index) {
        if (inputsBuilder_ == null) {
          return inputs_.get(index);
        } else {
          return inputsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder setInputs(
          int index, org.nd4j.ir.Nd4J.TensorProto value) {
        if (inputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputsIsMutable();
          inputs_.set(index, value);
          onChanged();
        } else {
          inputsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder setInputs(
          int index, org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (inputsBuilder_ == null) {
          ensureInputsIsMutable();
          inputs_.set(index, builderForValue.build());
          onChanged();
        } else {
          inputsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder addInputs(org.nd4j.ir.Nd4J.TensorProto value) {
        if (inputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputsIsMutable();
          inputs_.add(value);
          onChanged();
        } else {
          inputsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder addInputs(
          int index, org.nd4j.ir.Nd4J.TensorProto value) {
        if (inputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputsIsMutable();
          inputs_.add(index, value);
          onChanged();
        } else {
          inputsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder addInputs(
          org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (inputsBuilder_ == null) {
          ensureInputsIsMutable();
          inputs_.add(builderForValue.build());
          onChanged();
        } else {
          inputsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder addInputs(
          int index, org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (inputsBuilder_ == null) {
          ensureInputsIsMutable();
          inputs_.add(index, builderForValue.build());
          onChanged();
        } else {
          inputsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder addAllInputs(
          java.lang.Iterable<? extends org.nd4j.ir.Nd4J.TensorProto> values) {
        if (inputsBuilder_ == null) {
          ensureInputsIsMutable();
          org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
              values, inputs_);
          onChanged();
        } else {
          inputsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder clearInputs() {
        if (inputsBuilder_ == null) {
          inputs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          inputsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public Builder removeInputs(int index) {
        if (inputsBuilder_ == null) {
          ensureInputsIsMutable();
          inputs_.remove(index);
          onChanged();
        } else {
          inputsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder getInputsBuilder(
          int index) {
        return getInputsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProtoOrBuilder getInputsOrBuilder(
          int index) {
        if (inputsBuilder_ == null) {
          return inputs_.get(index);  } else {
          return inputsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
           getInputsOrBuilderList() {
        if (inputsBuilder_ != null) {
          return inputsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(inputs_);
        }
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder addInputsBuilder() {
        return getInputsFieldBuilder().addBuilder(
            org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder addInputsBuilder(
          int index) {
        return getInputsFieldBuilder().addBuilder(
            index, org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       *inputs and output ndarrays
       * </pre>
       *
       * <code>repeated .org.nd4j.ir.TensorProto inputs = 8;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorProto.Builder> 
           getInputsBuilderList() {
        return getInputsFieldBuilder().getBuilderList();
      }
      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
          getInputsFieldBuilder() {
        if (inputsBuilder_ == null) {
          inputsBuilder_ = new org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
              org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder>(
                  inputs_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          inputs_ = null;
        }
        return inputsBuilder_;
      }

      private java.util.List<org.nd4j.ir.Nd4J.TensorProto> outputs_ =
        java.util.Collections.emptyList();
      private void ensureOutputsIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          outputs_ = new java.util.ArrayList<org.nd4j.ir.Nd4J.TensorProto>(outputs_);
          bitField0_ |= 0x00000080;
         }
      }

      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder> outputsBuilder_;

      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorProto> getOutputsList() {
        if (outputsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(outputs_);
        } else {
          return outputsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public int getOutputsCount() {
        if (outputsBuilder_ == null) {
          return outputs_.size();
        } else {
          return outputsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto getOutputs(int index) {
        if (outputsBuilder_ == null) {
          return outputs_.get(index);
        } else {
          return outputsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder setOutputs(
          int index, org.nd4j.ir.Nd4J.TensorProto value) {
        if (outputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputsIsMutable();
          outputs_.set(index, value);
          onChanged();
        } else {
          outputsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder setOutputs(
          int index, org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (outputsBuilder_ == null) {
          ensureOutputsIsMutable();
          outputs_.set(index, builderForValue.build());
          onChanged();
        } else {
          outputsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder addOutputs(org.nd4j.ir.Nd4J.TensorProto value) {
        if (outputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputsIsMutable();
          outputs_.add(value);
          onChanged();
        } else {
          outputsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder addOutputs(
          int index, org.nd4j.ir.Nd4J.TensorProto value) {
        if (outputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputsIsMutable();
          outputs_.add(index, value);
          onChanged();
        } else {
          outputsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder addOutputs(
          org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (outputsBuilder_ == null) {
          ensureOutputsIsMutable();
          outputs_.add(builderForValue.build());
          onChanged();
        } else {
          outputsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder addOutputs(
          int index, org.nd4j.ir.Nd4J.TensorProto.Builder builderForValue) {
        if (outputsBuilder_ == null) {
          ensureOutputsIsMutable();
          outputs_.add(index, builderForValue.build());
          onChanged();
        } else {
          outputsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder addAllOutputs(
          java.lang.Iterable<? extends org.nd4j.ir.Nd4J.TensorProto> values) {
        if (outputsBuilder_ == null) {
          ensureOutputsIsMutable();
          org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(
              values, outputs_);
          onChanged();
        } else {
          outputsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder clearOutputs() {
        if (outputsBuilder_ == null) {
          outputs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          outputsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public Builder removeOutputs(int index) {
        if (outputsBuilder_ == null) {
          ensureOutputsIsMutable();
          outputs_.remove(index);
          onChanged();
        } else {
          outputsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder getOutputsBuilder(
          int index) {
        return getOutputsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProtoOrBuilder getOutputsOrBuilder(
          int index) {
        if (outputsBuilder_ == null) {
          return outputs_.get(index);  } else {
          return outputsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public java.util.List<? extends org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
           getOutputsOrBuilderList() {
        if (outputsBuilder_ != null) {
          return outputsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(outputs_);
        }
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder addOutputsBuilder() {
        return getOutputsFieldBuilder().addBuilder(
            org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance());
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public org.nd4j.ir.Nd4J.TensorProto.Builder addOutputsBuilder(
          int index) {
        return getOutputsFieldBuilder().addBuilder(
            index, org.nd4j.ir.Nd4J.TensorProto.getDefaultInstance());
      }
      /**
       * <code>repeated .org.nd4j.ir.TensorProto outputs = 9;</code>
       */
      public java.util.List<org.nd4j.ir.Nd4J.TensorProto.Builder> 
           getOutputsBuilderList() {
        return getOutputsFieldBuilder().getBuilderList();
      }
      private org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
          org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder> 
          getOutputsFieldBuilder() {
        if (outputsBuilder_ == null) {
          outputsBuilder_ = new org.nd4j.shade.protobuf.RepeatedFieldBuilderV3<
              org.nd4j.ir.Nd4J.TensorProto, org.nd4j.ir.Nd4J.TensorProto.Builder, org.nd4j.ir.Nd4J.TensorProtoOrBuilder>(
                  outputs_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          outputs_ = null;
        }
        return outputsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:org.nd4j.ir.Op)
    }

    // @@protoc_insertion_point(class_scope:org.nd4j.ir.Op)
    private static final org.nd4j.ir.Nd4J.Op DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.nd4j.ir.Nd4J.Op();
    }

    public static org.nd4j.ir.Nd4J.Op getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final org.nd4j.shade.protobuf.Parser<Op>
        PARSER = new org.nd4j.shade.protobuf.AbstractParser<Op>() {
      @java.lang.Override
      public Op parsePartialFrom(
          org.nd4j.shade.protobuf.CodedInputStream input,
          org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.nd4j.shade.protobuf.InvalidProtocolBufferException {
        return new Op(input, extensionRegistry);
      }
    };

    public static org.nd4j.shade.protobuf.Parser<Op> parser() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.shade.protobuf.Parser<Op> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.nd4j.ir.Nd4J.Op getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_StringStringEntryProto_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TypeProto_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TypeProto_Tensor_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TensorShapeProto_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_ValueInfoProto_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TensorProto_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_TensorProto_Segment_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable;
  private static final org.nd4j.shade.protobuf.Descriptors.Descriptor
    internal_static_org_nd4j_ir_Op_descriptor;
  private static final 
    org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_org_nd4j_ir_Op_fieldAccessorTable;

  public static org.nd4j.shade.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  org.nd4j.shade.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\nnd4j.proto\022\013org.nd4j.ir\"4\n\026StringStrin" +
      "gEntryProto\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"" +
      "\254\001\n\tTypeProto\0224\n\013tensor_type\030\001 \001(\0132\035.org" +
      ".nd4j.ir.TypeProto.TensorH\000\032`\n\006Tensor\022(\n" +
      "\telem_type\030\001 \001(\0162\025.org.nd4j.ir.DataType\022" +
      ",\n\005shape\030\002 \001(\0132\035.org.nd4j.ir.TensorShape" +
      "ProtoB\007\n\005value\"\210\001\n\020TensorShapeProto\0224\n\003d" +
      "im\030\001 \003(\0132\'.org.nd4j.ir.TensorShapeProto." +
      "Dimension\032>\n\tDimension\022\023\n\tdim_value\030\001 \001(" +
      "\003H\000\022\023\n\tdim_param\030\002 \001(\tH\000B\007\n\005value\"X\n\016Val" +
      "ueInfoProto\022\014\n\004name\030\001 \001(\t\022$\n\004type\030\002 \001(\0132" +
      "\026.org.nd4j.ir.TypeProto\022\022\n\ndoc_string\030\003 " +
      "\001(\t\"\360\003\n\013TensorProto\022\014\n\004dims\030\001 \003(\003\022\021\n\tdat" +
      "a_type\030\002 \001(\005\0221\n\007segment\030\003 \001(\0132 .org.nd4j" +
      ".ir.TensorProto.Segment\022\026\n\nfloat_data\030\004 " +
      "\003(\002B\002\020\001\022\026\n\nint32_data\030\005 \003(\005B\002\020\001\022\023\n\013strin" +
      "g_data\030\006 \003(\014\022\026\n\nint64_data\030\007 \003(\003B\002\020\001\022\014\n\004" +
      "name\030\010 \001(\t\022\022\n\ndoc_string\030\014 \001(\t\022\020\n\010raw_da" +
      "ta\030\t \001(\014\022:\n\rexternal_data\030\r \003(\0132#.org.nd" +
      "4j.ir.StringStringEntryProto\022<\n\rdata_loc" +
      "ation\030\016 \001(\0162%.org.nd4j.ir.TensorProto.Da" +
      "taLocation\022\027\n\013double_data\030\n \003(\001B\002\020\001\022\027\n\013u" +
      "int64_data\030\013 \003(\004B\002\020\001\032%\n\007Segment\022\r\n\005begin" +
      "\030\001 \001(\003\022\013\n\003end\030\002 \001(\003\")\n\014DataLocation\022\013\n\007D" +
      "EFAULT\020\000\022\014\n\010EXTERNAL\020\001\"\363\001\n\002Op\022\014\n\004name\030\001 " +
      "\001(\t\022\022\n\nfloatTArgs\030\002 \003(\002\022\023\n\013doubleTArgs\030\003" +
      " \003(\002\022\017\n\007intArgs\030\004 \003(\005\022\021\n\tint64Args\030\005 \003(\005" +
      "\022\020\n\010boolArgs\030\006 \003(\010\022+\n\014dataTypeArgs\030\007 \003(\016" +
      "2\025.org.nd4j.ir.DataType\022(\n\006inputs\030\010 \003(\0132" +
      "\030.org.nd4j.ir.TensorProto\022)\n\007outputs\030\t \003" +
      "(\0132\030.org.nd4j.ir.TensorProto*\332\001\n\010DataTyp" +
      "e\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020\001\022\t\n\005UINT8\020\002\022\010" +
      "\n\004INT8\020\003\022\n\n\006UINT16\020\004\022\t\n\005INT16\020\005\022\t\n\005INT32" +
      "\020\006\022\t\n\005INT64\020\007\022\n\n\006STRING\020\010\022\010\n\004BOOL\020\t\022\013\n\007F" +
      "LOAT16\020\n\022\n\n\006DOUBLE\020\013\022\n\n\006UINT32\020\014\022\n\n\006UINT" +
      "64\020\r\022\r\n\tCOMPLEX64\020\016\022\016\n\nCOMPLEX128\020\017\022\014\n\010B" +
      "FLOAT16\020\020*b\n\nOpListType\022\010\n\004TARG\020\000\022\010\n\004IAR" +
      "G\020\001\022\010\n\004BARG\020\002\022\014\n\010DTYPEARG\020\003\022\014\n\010INPUTARG\020" +
      "\004\022\r\n\tOUTPUTARG\020\005\022\013\n\007AXISARG\020\006b\006proto3"
    };
    descriptor = org.nd4j.shade.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new org.nd4j.shade.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_org_nd4j_ir_StringStringEntryProto_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_StringStringEntryProto_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_org_nd4j_ir_TypeProto_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TypeProto_descriptor,
        new java.lang.String[] { "TensorType", "Value", });
    internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor =
      internal_static_org_nd4j_ir_TypeProto_descriptor.getNestedTypes().get(0);
    internal_static_org_nd4j_ir_TypeProto_Tensor_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TypeProto_Tensor_descriptor,
        new java.lang.String[] { "ElemType", "Shape", });
    internal_static_org_nd4j_ir_TensorShapeProto_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TensorShapeProto_descriptor,
        new java.lang.String[] { "Dim", });
    internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor =
      internal_static_org_nd4j_ir_TensorShapeProto_descriptor.getNestedTypes().get(0);
    internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor,
        new java.lang.String[] { "DimValue", "DimParam", "Value", });
    internal_static_org_nd4j_ir_ValueInfoProto_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_ValueInfoProto_descriptor,
        new java.lang.String[] { "Name", "Type", "DocString", });
    internal_static_org_nd4j_ir_TensorProto_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TensorProto_descriptor,
        new java.lang.String[] { "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "ExternalData", "DataLocation", "DoubleData", "Uint64Data", });
    internal_static_org_nd4j_ir_TensorProto_Segment_descriptor =
      internal_static_org_nd4j_ir_TensorProto_descriptor.getNestedTypes().get(0);
    internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_TensorProto_Segment_descriptor,
        new java.lang.String[] { "Begin", "End", });
    internal_static_org_nd4j_ir_Op_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_org_nd4j_ir_Op_fieldAccessorTable = new
      org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_org_nd4j_ir_Op_descriptor,
        new java.lang.String[] { "Name", "FloatTArgs", "DoubleTArgs", "IntArgs", "Int64Args", "BoolArgs", "DataTypeArgs", "Inputs", "Outputs", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
